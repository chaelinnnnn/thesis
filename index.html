<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Appropriation Film — Visible Area Only</title>
  <style>
    :root{
      --bg:#ffffff;
      --ink:#111;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    body{ margin:0; background:var(--bg); color:var(--ink); }
    .wrap{ width:min(920px, 92vw); margin:0 auto; padding:44px 16px 180px; }
    header{
      position: sticky; top: 0; z-index: 3;
      background: rgba(255,255,255,.86);
      backdrop-filter: blur(8px);
      border-bottom: 1px solid rgba(0,0,0,.08);
      padding: 10px 0 12px;
    }
    header h1{ margin:0; font-family:var(--sans); font-size:18px; font-weight:700; }
    header p{ margin:6px 0 0; font-size:13px; opacity:.72; }

    #content{
      margin-top: 16px;
      font-family: var(--mono);
      font-size: 16px;
      line-height: 1.95;
      white-space: pre-wrap;
      word-break: keep-all;
      letter-spacing: .01em;
    }

    .sent{ display:inline; padding:2px 0; border-radius:8px; }

    /* 치환된 단어만 살짝 표시(무채색) */
    .tok.ap{
      background: rgba(0,0,0,.06);
      box-shadow: 0 0 0 1px rgba(0,0,0,.10) inset;
      border-radius: 8px;
      padding: 0 2px;
      font-weight: 750;
      color:#000;
    }

    /* 우하단 스와치(필름 열기/닫기) */
    #swatch{
      position: fixed; right: 18px; bottom: 18px;
      width: 52px; height: 52px;
      border-radius: 44% 56% 42% 58% / 54% 40% 60% 46%;
      border: 1px solid rgba(0,0,0,.14);
      background: rgba(255,255,255,.9);
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 30px rgba(0,0,0,.12);
      cursor: pointer; z-index: 9999;
      display:grid; place-items:center; user-select:none;
    }
    #swatch .inner{
      width: 18px; height: 18px; border-radius: 999px;
      background: rgba(0,0,0,.82);
      box-shadow: 0 0 0 6px rgba(0,0,0,.06), 0 0 0 1px rgba(0,0,0,.14) inset;
    }

    /* 블롭 셀로판 필름 */
    #film{
      position: fixed;
      right: 18px; bottom: 78px;
      width: min(560px, 86vw);
      height: min(380px, 52vh);

      border-radius: 48% 52% 44% 56% / 55% 38% 62% 45%;
      border: 1px solid rgba(0,0,0,.18);
      background: rgba(0,0,0,.05);
      backdrop-filter: blur(2px) contrast(105%);
      box-shadow: 0 12px 40px rgba(0,0,0,.18);
      z-index: 9998;

      transform-origin: 100% 100%;
      transform: scale(0.15);
      opacity: 0;
      pointer-events: none;
      transition: transform .22s ease, opacity .22s ease;
      overflow: hidden;
    }
    body.filmOn #film{
      transform: scale(1);
      opacity: 1;
      pointer-events: auto;
    }

    /* 필름 질감 */
    #film::before{
      content:"";
      position:absolute; inset:-24px;
      background:
        radial-gradient(circle at 20% 30%, rgba(255,255,255,.30), transparent 55%),
        radial-gradient(circle at 70% 60%, rgba(255,255,255,.18), transparent 50%),
        repeating-linear-gradient(25deg, rgba(255,255,255,.14) 0 2px, transparent 2px 8px);
      opacity:.35;
      mix-blend-mode: screen;
      pointer-events:none;
    }
    #film::after{
      content:"";
      position:absolute; inset:-10px;
      background: radial-gradient(rgba(0,0,0,.22) 1px, transparent 1.8px);
      background-size: 11px 11px;
      opacity:.10;
      mix-blend-mode: multiply;
      pointer-events:none;
    }

    /* 드래그 핸들 */
    #filmHeader{
      height: 28px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 0 10px;
      font-family: var(--sans);
      font-size: 12px;
      color: rgba(0,0,0,.55);
      border-bottom: 1px solid rgba(0,0,0,.10);
      background: rgba(255,255,255,.45);
      cursor: grab;
      user-select:none;
      position: relative;
      z-index: 2;
    }
    #filmHeader:active{ cursor: grabbing; }
    #closeFilm{
      border:none; background:transparent; cursor:pointer;
      font-size:16px; line-height:1; opacity:.6;
    }

    /* 필름 내부 설명은 최소화 (안 보이게 해도 됨) */
    #filmBody{
      height: calc(100% - 28px);
      padding: 10px;
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.55;
      color: rgba(0,0,0,.0); /* 거의 안 보이게 */
      user-select:none;
      pointer-events:none;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>전유된 대화: 내 욕망으로 번역되는 타자의 목소리</h1>
      <p>우측 하단의 점을 눌러 필름을 켠 뒤, 필름을 움직이면 그 영역에 걸린 문장만 ‘단어 위주’로 강제 번역됩니다.</p>
    </header>
    <div id="content"></div>
  </div>

  <div id="swatch" aria-label="Open film"><div class="inner"></div></div>

  <div id="film" role="dialog" aria-label="Appropriation film">
    <div id="filmHeader">
      <span>FILM</span>
      <button id="closeFilm" aria-label="Close">×</button>
    </div>
    <div id="filmBody">drag</div>
  </div>

  <script>
    // ✅ 여기에 원문 전체 붙여넣기 (길어도 OK)
    const TEXT = `
They discovered the beauty of merchandise and started making it relentlessly.
After a time, there was so much merchandise that they had to build new houses to shelter and distribute it everywhere.
Once these stone houses had proliferated, they connected them to each other with tangled paths and gave them the name "city."
This is how little by little the forest disappeared from their land along with the game that inhabited it.

The napenaperi spirits want to keep the beauty of their mirror-land and protect it from epidemic fumes.
Bees are also xapiri; this is why their images spoke to me this way during my sleep.
`.trim();

    // ✅ 치환 목록(명사/핵심어 위주)
    const NOUN_MAP = [
      { re: /\bforest\b/gi, to: "Asset" },
      { re: /\btrees?\b/gi, to: "Resource" },
      { re: /\bspirits?\b/gi, to: "IP" },
      { re: /\bxapiri\b/gi, to: "Intangible" },
      { re: /\bbees?\b/gi, to: "Product" },
      { re: /\bhoney\b/gi, to: "Revenue" },
      { re: /\bflowers?\b/gi, to: "Input" },
      { re: /\bland\b/gi, to: "Property" },
      { re: /\bknowledge\b/gi, to: "Patent" },
      { re: /\blaw\b/gi, to: "Policy" },
      { re: /\bmemory\b/gi, to: "Database" },
      { re: /\bsong(s)?\b/gi, to: "Content" },
      { re: /\bimage(s)?\b/gi, to: "Brand" },
      { re: /\bmedicine\b/gi, to: "Product" },
      { re: /\bmerchandise\b/gi, to: "Inventory" },
      { re: /\bcities?\b/gi, to: "Market" },
      { re: /\bhouses?\b/gi, to: "Facility" },
      { re: /\bgardens?\b/gi, to: "Production" },
      { re: /\bgame\b/gi, to: "Stock" },
    ];

    function escapeHtml(str){
      return str
        .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
        .replaceAll('"',"&quot;").replaceAll("'","&#039;");
    }

    // 문장 분리(가벼운 버전)
    function splitSentences(text){
      const paras = text.replace(/\r/g,"").split(/\n{2,}/);
      return paras.map(p => p.split(/(?<=[.!?])\s+(?=[A-Z“"‘(])/g));
    }

    // ✅ 문장 안에서 “명사/키워드만” 치환해서 HTML 생성
    function nounOnlyTransform(sentence){
      // 모든 매치를 수집해서 겹치지 않게 선택 후 조립
      const marks = [];
      NOUN_MAP.forEach(({re,to}) => {
        let m;
        while ((m = re.exec(sentence)) !== null) {
          marks.push({ start: m.index, end: m.index + m[0].length, repl: to });
          if (m.index === re.lastIndex) re.lastIndex++;
        }
        re.lastIndex = 0;
      });

      if (marks.length === 0) return escapeHtml(sentence);

      // 긴 매치 우선, 겹치면 버림
      marks.sort((a,b)=> (b.end-b.start)-(a.end-a.start) || a.start-b.start);
      const chosen = [];
      const occupied = [];
      const overlaps = (a,b)=> !(a.end<=b.start || a.start>=b.end);

      for (const mk of marks){
        if (occupied.some(o => overlaps(o, mk))) continue;
        chosen.push(mk);
        occupied.push({start: mk.start, end: mk.end});
      }
      chosen.sort((a,b)=>a.start-b.start);

      let out = "";
      let cur = 0;
      for (const mk of chosen){
        out += escapeHtml(sentence.slice(cur, mk.start));
        out += `<span class="tok ap">${escapeHtml(mk.repl)}</span>`;
        cur = mk.end;
      }
      out += escapeHtml(sentence.slice(cur));
      return out;
    }

    // 렌더
    const content = document.getElementById("content");
    const model = splitSentences(TEXT);

    function render(){
      content.innerHTML = "";
      model.forEach(sentList => {
        sentList.forEach(s => {
          const span = document.createElement("span");
          span.className = "sent";
          span.dataset.orig = s;
          span.dataset.transHtml = nounOnlyTransform(s);
          span.dataset.state = "orig";
          span.innerHTML = escapeHtml(s);
          content.appendChild(span);
          content.appendChild(document.createTextNode(" "));
        });
        content.appendChild(document.createTextNode("\n\n"));
      });
    }
    render();

    // 필름 토글
    const swatch = document.getElementById("swatch");
    const film = document.getElementById("film");
    const closeFilm = document.getElementById("closeFilm");
    const filmHeader = document.getElementById("filmHeader");

    let filmOn = false;
    function setFilm(on){
      filmOn = on;
      document.body.classList.toggle("filmOn", on);
      if (on) updateAppropriation();
      else clearAll();
    }
    swatch.addEventListener("click", () => setFilm(!filmOn));
    closeFilm.addEventListener("click", () => setFilm(false));

    // 드래그 이동
    let drag = { on:false, startX:0, startY:0, baseX:0, baseY:0 };

    function ensureFilmPositioned(){
      const r = film.getBoundingClientRect();
      if (film.style.left) return;
      film.style.left = r.left + "px";
      film.style.top  = r.top  + "px";
      film.style.right = "auto";
      film.style.bottom = "auto";
    }

    filmHeader.addEventListener("pointerdown", (e) => {
      if (!filmOn) return;
      ensureFilmPositioned();
      drag.on = true;
      drag.startX = e.clientX;
      drag.startY = e.clientY;
      drag.baseX = parseFloat(film.style.left);
      drag.baseY = parseFloat(film.style.top);
      filmHeader.setPointerCapture(e.pointerId);
    });

    filmHeader.addEventListener("pointermove", (e) => {
      if (!drag.on) return;
      const dx = e.clientX - drag.startX;
      const dy = e.clientY - drag.startY;
      film.style.left = (drag.baseX + dx) + "px";
      film.style.top  = (drag.baseY + dy) + "px";
      updateAppropriation(); // ✅ 움직일 때마다 즉시 갱신
    });

    filmHeader.addEventListener("pointerup", (e) => {
      drag.on = false;
      try { filmHeader.releasePointerCapture(e.pointerId); } catch {}
    });

    // 필름 안에 "보이는 영역"에 걸린 문장만 치환
    const spans = () => Array.from(content.querySelectorAll(".sent"));
    function rectsOverlap(a,b){
      return !(a.right < b.left || a.left > b.right || a.bottom < b.top || a.top > b.bottom);
    }

    function appropriate(span){
      if (span.dataset.state === "ap") return;
      span.dataset.state = "ap";
      span.innerHTML = span.dataset.transHtml || escapeHtml(span.dataset.orig || "");
    }
    function restore(span){
      if (span.dataset.state !== "ap") return;
      span.dataset.state = "orig";
      span.innerHTML = escapeHtml(span.dataset.orig || "");
    }
    function clearAll(){ spans().forEach(restore); }

    function updateAppropriation(){
      if (!filmOn) return;

      const f = film.getBoundingClientRect();
      // 헤더 제외한 “필름 내용 영역”만 유효 범위로 잡기
      const effective = {
        left: f.left + 12,
        top: f.top + 40,
        right: f.right - 12,
        bottom: f.bottom - 12
      };

      spans().forEach(sp => {
        const r = sp.getBoundingClientRect();
        const hit = rectsOverlap(r, effective);
        if (hit) appropriate(sp);
        else restore(sp);
      });
    }

    window.addEventListener("scroll", () => updateAppropriation(), { passive:true });
    window.addEventListener("resize", () => updateAppropriation());
  </script>
</body>
</html>
