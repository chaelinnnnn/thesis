<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Appropriation Lens — Virus Glyphs</title>
  <style>
    :root{
      --bg:#ffffff;
      --ink:#111;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    body{ margin:0; background:var(--bg); color:var(--ink); }

    .wrap{ width:min(920px, 92vw); margin:0 auto; padding:44px 16px 300px; }
    header{
      position: sticky; top: 0; z-index: 3;
      background: rgba(255,255,255,.92);
      border-bottom: 1px solid rgba(0,0,0,.08);
      padding: 10px 0 12px;
    }
    header h1{ margin:0; font-family:var(--sans); font-size:18px; font-weight:700; }
    header p{ margin:6px 0 0; font-size:13px; opacity:.72; }

    #content{
      position: relative;
      margin-top: 16px;
      font-family: var(--mono);
      font-size: 16px;
      line-height: 1.95;
      white-space: pre-wrap;
      word-break: keep-all;
      letter-spacing: .01em;
    }

    /* 단어 토큰(원문은 유지) */
    .w{ display:inline; position:relative; padding:0 2px; border-radius:10px; }

    /* 렌즈 안에서 “치환됨” 상태일 때, 원래 글자는 숨김(공간은 유지) */
    .w.hiddenInk{
      color: transparent;
      text-shadow: none;
    }

    /* 토글 스와치 */
    #swatch{
      position: fixed; right: 18px; bottom: 44px;
      width: 52px; height: 52px;
      border-radius: 18px;
      border: 1px solid rgba(0,0,0,.14);
      background: rgba(255,255,255,.92);
      box-shadow: 0 8px 30px rgba(0,0,0,.12);
      cursor: pointer; z-index: 9999;
      display:grid; place-items:center; user-select:none;
    }
    #swatch .inner{
      width: 18px; height: 18px; border-radius: 999px;
      background: rgba(0,0,0,.82);
      box-shadow: 0 0 0 6px rgba(0,0,0,.06), 0 0 0 1px rgba(0,0,0,.14) inset;
    }

    /* 렌즈 */
    #lensWrap{
      position: fixed; inset:0; z-index:9998;
      opacity:0; transition:opacity .16s ease;
      pointer-events:none;
    }
    body.lensOn #lensWrap{ opacity:1; }

    #lens{
      position: fixed;
      left: 50%; top: 58%;
      width: 420px; height: 420px;
      transform: translate(-50%,-50%);
      border-radius: 999px;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(0,0,0,.18);
      box-shadow: 0 14px 40px rgba(0,0,0,.10), 0 0 0 1px rgba(255,255,255,.75) inset;
      opacity:0; pointer-events:none;
      transition: opacity .16s ease;
      touch-action:none;
      overflow:hidden;
    }
    body.lensOn #lens{ opacity:1; pointer-events:auto; }

    #lens::before{
      content:"";
      position:absolute; inset:-40px;
      background:
        radial-gradient(circle at 30% 25%, rgba(255,255,255,.55), transparent 45%),
        radial-gradient(circle at 70% 70%, rgba(255,255,255,.22), transparent 55%),
        linear-gradient(135deg, rgba(255,255,255,.18), transparent 60%);
      opacity:.35;
      mix-blend-mode: screen;
      pointer-events:none;
    }
    #lens::after{
      content:"";
      position:absolute; inset:10px;
      border-radius: 999px;
      box-shadow: 0 0 0 1px rgba(0,0,0,.08) inset, 0 -10px 25px rgba(255,255,255,.25) inset;
      pointer-events:none;
    }

    #handle{
      position:absolute; left:50%; top:50%;
      transform: translate(150px, 150px);
      width:40px; height:40px;
      border-radius:999px;
      background: rgba(255,255,255,.78);
      border: 1px solid rgba(0,0,0,.10);
      box-shadow: 0 10px 28px rgba(0,0,0,.14);
      display:grid; place-items:center;
      pointer-events:none; opacity:.9;
    }
    #handle::before{
      content:"";
      width:12px; height:12px;
      border-radius:999px;
      background: rgba(0,0,0,.82);
      box-shadow: 0 0 0 6px rgba(0,0,0,.05);
    }

    /* ✅ 바이러스 글자 오버레이(페이지 전체) */
    #virusOverlay{
      position: fixed;
      inset: 0;
      z-index: 9996; /* 렌즈 아래, 본문 위처럼 보이게 */
      pointer-events: none;
      opacity: 1;
    }

    /* 하단 trace bar */
    #traceBar{
      position: fixed; left:0; bottom:0;
      width:100%; height:22px;
      background: rgba(255,255,255,.90);
      border-top: 1px solid rgba(0,0,0,.06);
      display:flex; align-items:center; gap:2px;
      padding:0 6px;
      z-index: 9997;
      pointer-events:none;
      overflow:hidden;
    }
    .trace{
      flex:1; height:6px; border-radius:3px;
      opacity:.18; filter:saturate(115%);
    }

    #hint{
      position: fixed; left:18px; bottom:44px;
      font-family: var(--sans);
      font-size: 12px;
      opacity:.58;
      background: rgba(255,255,255,.92);
      border: 1px solid rgba(0,0,0,.10);
      padding: 6px 10px;
      border-radius: 999px;
      z-index: 9999;
      user-select:none;
      pointer-events:none;
    }
  </style>
</head>
<body>

  <!-- ✅ SVG 필터(글자 자체를 덩어리/바이러스화) -->
  <svg width="0" height="0" style="position:absolute">
    <!-- 1) 울렁임 -->
    <filter id="warp">
      <feTurbulence type="fractalNoise" baseFrequency="0.018" numOctaves="2" seed="8" result="n">
        <animate attributeName="baseFrequency" dur="6s" values="0.014;0.020;0.014" repeatCount="indefinite"/>
      </feTurbulence>
      <feDisplacementMap in="SourceGraphic" in2="n" scale="18" xChannelSelector="R" yChannelSelector="G"/>
    </filter>

    <!-- 2) 덩어리/바이러스 질감(거친 노이즈 + 경계) -->
    <filter id="virusGlyph">
      <feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="1" seed="3" result="g"/>
      <feColorMatrix in="g" type="matrix"
        values="
          1 0 0 0 0
          0 1 0 0 0
          0 0 1 0 0
          0 0 0 .55 0" result="grain"/>
      <feComposite in="SourceGraphic" in2="grain" operator="arithmetic" k1="0" k2="1" k3="0.35" k4="0" result="mix"/>
      <feGaussianBlur in="mix" stdDeviation="0.25" result="soft"/>
      <feDisplacementMap in="soft" in2="g" scale="10" xChannelSelector="R" yChannelSelector="G" result="warped"/>
      <feComposite in="warped" in2="SourceGraphic" operator="over"/>
    </filter>
  </svg>

  <div class="wrap">
    <header>
      <h1>전유된 대화: 내 욕망으로 번역되는 타자의 목소리</h1>
      <p>스와치로 렌즈 ON/OFF. 렌즈 안에서만 단어가 “바이러스 글자(형태 자체 변형)”로 치환됩니다.</p>
    </header>
    <div id="content"></div>
  </div>

  <!-- ✅ 오버레이: 바이러스 글자를 SVG로 다시 그려서 “형태 자체”를 바꿈 -->
  <svg id="virusOverlay"></svg>

  <div id="swatch" aria-label="Toggle lens"><div class="inner"></div></div>
  <div id="lensWrap" aria-hidden="true">
    <div id="lens" aria-label="Lens">
      <div id="handle" aria-hidden="true"></div>
    </div>
  </div>

  <div id="hint">Lens: OFF</div>
  <div id="traceBar" aria-hidden="true"></div>

  <script>
    const TEXT = `
They were the ones who put the tall stones of Omama’s house in place and created the first merchandise, paper skins, and medicine.

The napenaperi spirits want to keep the beauty of their mirror-land and protect it from epidemic fumes. Yet today’s white people no longer know how to take care of it, and they know nothing of these images, which are those of their ancestors.

In the past, their long-ago elders knew them and made them dance. They knew how to imitate their songs and build their spirit houses. But then those who were born after them began to create the cities. Little by little they stopped hearing these spirits’ words. Then the books made them forgetful, and they finally rejected them.

Bees are also xapiri; this is why their images spoke to me this way during my sleep. They wanted to tell me of their concern: “The white people truly lack wisdom. They must stop mistreating the trees in the forest. Soon there will be no more flowers to feed us and make honey.”

This is how little by little the forest disappeared from their land.
`.trim();

    // ✅ 10개 키워드 + 다채로운 컬러
    const NOUN_MAP = [
      { re: /^forest$/i,     to: "Asset",      color: "#2a7fff" },
      { re: /^xapiri$/i,     to: "Intangible", color: "#00b894" },
      { re: /^bee(s)?$/i,    to: "Product",    color: "#ffd400" },
      { re: /^honey$/i,      to: "Revenue",    color: "#ff8a00" },
      { re: /^flower(s)?$/i, to: "Input",      color: "#38d9a9" },
      { re: /^land$/i,       to: "Property",   color: "#845ef7" },
      { re: /^knowledge$/i,  to: "Patent",     color: "#ff3dce" },
      { re: /^law$/i,        to: "Policy",     color: "#2a7fff" },
      { re: /^memory$/i,     to: "Database",   color: "#00b894" },
      { re: /^medicine$/i,   to: "Product",    color: "#ff4d4d" },
    ];

    const content = document.getElementById("content");
    const lens = document.getElementById("lens");
    const swatch = document.getElementById("swatch");
    const hint = document.getElementById("hint");
    const traceBar = document.getElementById("traceBar");
    const overlay = document.getElementById("virusOverlay");

    let lensOn = false;

    // overlay 크기 세팅
    function sizeOverlay(){
      overlay.setAttribute("width", window.innerWidth);
      overlay.setAttribute("height", window.innerHeight);
      overlay.setAttribute("viewBox", `0 0 ${window.innerWidth} ${window.innerHeight}`);
    }
    sizeOverlay();

    function renderTokenized(text){
      const parts = text.split(/([A-Za-z]+(?:'[A-Za-z]+)?)/g);
      const frag = document.createDocumentFragment();
      for (const p of parts){
        if (!p) continue;
        if (/^[A-Za-z]+(?:'[A-Za-z]+)?$/.test(p)){
          const span = document.createElement("span");
          span.className = "w";
          span.dataset.orig = p;
          span.textContent = p;
          frag.appendChild(span);
        } else {
          frag.appendChild(document.createTextNode(p));
        }
      }
      content.textContent = "";
      content.appendChild(frag);
    }

    function lookupWord(word){
      for (const entry of NOUN_MAP){
        if (entry.re.test(word)) return entry;
      }
      return null;
    }

    function addTrace(color){
      const t = document.createElement("div");
      t.className = "trace";
      t.style.background = color;
      traceBar.appendChild(t);
      const MAX = 90;
      while (traceBar.children.length > MAX){
        traceBar.removeChild(traceBar.firstChild);
      }
    }

    renderTokenized(TEXT);
    const wordSpans = () => Array.from(content.querySelectorAll(".w"));

    function clearOverlay(){
      overlay.innerHTML = "";
    }

    // SVG에 “바이러스 글자” 그리기
    function drawVirusWord({x, y, text, fontSize, color}){
      const ns = "http://www.w3.org/2000/svg";

      // 그룹
      const g = document.createElementNS(ns, "g");
      g.setAttribute("transform", `translate(${x}, ${y})`);

      // (1) 바깥 검은 외곽선(두껍게)
      const outline = document.createElementNS(ns, "text");
      outline.textContent = text;
      outline.setAttribute("x", "0");
      outline.setAttribute("y", "0");
      outline.setAttribute("font-family", getComputedStyle(content).fontFamily);
      outline.setAttribute("font-size", fontSize);
      outline.setAttribute("font-weight", "900");
      outline.setAttribute("fill", "none");
      outline.setAttribute("stroke", "rgba(0,0,0,.95)");
      outline.setAttribute("stroke-width", "6");
      outline.setAttribute("stroke-linejoin", "round");
      outline.setAttribute("paint-order", "stroke");
      outline.setAttribute("filter", "url(#warp)");

      // (2) 컬러 본체(덩어리/질감)
      const fill = document.createElementNS(ns, "text");
      fill.textContent = text;
      fill.setAttribute("x", "0");
      fill.setAttribute("y", "0");
      fill.setAttribute("font-family", getComputedStyle(content).fontFamily);
      fill.setAttribute("font-size", fontSize);
      fill.setAttribute("font-weight", "900");
      fill.setAttribute("fill", color);
      fill.setAttribute("filter", "url(#virusGlyph)");

      // (3) 하이라이트(살짝 밝은 톤)
      const hi = document.createElementNS(ns, "text");
      hi.textContent = text;
      hi.setAttribute("x", "0");
      hi.setAttribute("y", "0");
      hi.setAttribute("font-family", getComputedStyle(content).fontFamily);
      hi.setAttribute("font-size", fontSize);
      hi.setAttribute("font-weight", "900");
      hi.setAttribute("fill", "rgba(255,255,255,.55)");
      hi.setAttribute("filter", "url(#warp)");
      hi.setAttribute("opacity", ".18");

      g.appendChild(outline);
      g.appendChild(fill);
      g.appendChild(hi);

      overlay.appendChild(g);
    }

    // 렌즈 안 단어만 치환 + 오버레이로 바이러스 글자 그리기
    function updateLensEffect(){
      if (!lensOn) return;

      clearOverlay();

      const lr = lens.getBoundingClientRect();
      const cx = lr.left + lr.width / 2;
      const cy = lr.top + lr.height / 2;
      const radius = lr.width / 2;

      const baseFontSize = parseFloat(getComputedStyle(content).fontSize);

      for (const sp of wordSpans()){
        const r = sp.getBoundingClientRect();
        const wx = r.left + r.width / 2;
        const wy = r.top + r.height / 2;
        const inside = ((wx - cx) ** 2 + (wy - cy) ** 2) <= (radius ** 2);

        const orig = sp.dataset.orig || "";

        if (inside){
          const entry = lookupWord(orig);
          if (entry){
            // 원 글자는 숨기고(공간 유지)
            sp.classList.add("hiddenInk");

            // 화면 좌표에 바이러스 글자 그리기
            // SVG text는 baseline 기준이라 y에 height*0.78 정도 더해 맞춤
            drawVirusWord({
              x: r.left,
              y: r.top + r.height * 0.78,
              text: entry.to,
              fontSize: baseFontSize,
              color: entry.color
            });

            // trace는 최초 치환 순간에만 쌓이게(데이터 플래그)
            if (sp.dataset.traced !== "1"){
              addTrace(entry.color);
              sp.dataset.traced = "1";
            }
          } else {
            sp.classList.remove("hiddenInk");
          }
        } else {
          sp.classList.remove("hiddenInk");
        }
      }
    }

    function setLens(on){
      lensOn = on;
      document.body.classList.toggle("lensOn", on);
      hint.textContent = on ? "Lens: ON (drag)" : "Lens: OFF";

      clearOverlay();

      if (!on){
        for (const sp of wordSpans()){
          sp.classList.remove("hiddenInk");
        }
      } else {
        updateLensEffect();
      }
    }

    swatch.addEventListener("click", () => setLens(!lensOn));

    // 드래그
    let dragging = false;
    let offsetX = 0, offsetY = 0;

    function moveLensTo(clientX, clientY){
      const w = lens.offsetWidth;
      const h = lens.offsetHeight;
      const x = Math.max(-w*0.25, Math.min(window.innerWidth - w*0.75, clientX - offsetX));
      const y = Math.max(-h*0.25, Math.min(window.innerHeight - h*0.75, clientY - offsetY));
      lens.style.left = x + "px";
      lens.style.top  = y + "px";
      lens.style.transform = "translate(0,0)";
      updateLensEffect();
    }

    lens.addEventListener("pointerdown", (e) => {
      if (!lensOn) return;
      dragging = true;
      const r = lens.getBoundingClientRect();
      offsetX = e.clientX - r.left;
      offsetY = e.clientY - r.top;
      lens.setPointerCapture(e.pointerId);
    });

    lens.addEventListener("pointermove", (e) => {
      if (!dragging) return;
      moveLensTo(e.clientX, e.clientY);
    });

    lens.addEventListener("pointerup", (e) => {
      dragging = false;
      try { lens.releasePointerCapture(e.pointerId); } catch {}
    });

    window.addEventListener("scroll", () => updateLensEffect(), { passive:true });
    window.addEventListener("resize", () => { sizeOverlay(); updateLensEffect(); });
  </script>
</body>
</html>
