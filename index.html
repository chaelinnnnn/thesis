<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Appropriation Lens — Word-only</title>
  <style>
    :root{
      --bg:#ffffff;
      --ink:#111;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    body{ margin:0; background:var(--bg); color:var(--ink); }

    .wrap{ width:min(920px, 92vw); margin:0 auto; padding:44px 16px 220px; }
    header{
      position: sticky; top: 0; z-index: 3;
      background: rgba(255,255,255,.86);
      backdrop-filter: blur(8px);
      border-bottom: 1px solid rgba(0,0,0,.08);
      padding: 10px 0 12px;
    }
    header h1{ margin:0; font-family:var(--sans); font-size:18px; font-weight:700; }
    header p{ margin:6px 0 0; font-size:13px; opacity:.72; }

    #content{
      margin-top: 16px;
      font-family: var(--mono);
      font-size: 16px;
      line-height: 1.95;
      white-space: pre-wrap;
      word-break: keep-all;
      letter-spacing: .01em;
    }

    /* 단어 토큰 */
    .w{
      display:inline;
      border-radius: 8px;
      padding: 0 2px;
    }
    /* 렌즈 안에서 치환된 단어 */
    .w.ap{
      background: rgba(0,0,0,.06);
      box-shadow: 0 0 0 1px rgba(0,0,0,.10) inset;
      font-weight: 750;
      color:#000;
    }

    /* 우하단: 렌즈 ON/OFF 스와치 */
    #swatch{
      position: fixed; right: 18px; bottom: 18px;
      width: 52px; height: 52px;
      border-radius: 18px;
      border: 1px solid rgba(0,0,0,.14);
      background: rgba(255,255,255,.9);
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 30px rgba(0,0,0,.12);
      cursor: pointer; z-index: 9999;
      display:grid; place-items:center; user-select:none;
    }
    #swatch .inner{
      width: 18px; height: 18px; border-radius: 999px;
      background: rgba(0,0,0,.82);
      box-shadow: 0 0 0 6px rgba(0,0,0,.06), 0 0 0 1px rgba(0,0,0,.14) inset;
    }

    /* ✅ 동그란 렌즈(필름) */
    #lens{
      position: fixed;
      left: 50%; top: 55%;
      width: 220px; height: 220px;
      transform: translate(-50%,-50%);
      border-radius: 999px;
      border: 1px solid rgba(0,0,0,.18);
      background: rgba(0,0,0,.05);
      backdrop-filter: blur(2px) contrast(105%);
      box-shadow: 0 16px 50px rgba(0,0,0,.18);
      z-index: 9998;

      opacity: 0;
      pointer-events: none;
      transition: opacity .18s ease, transform .18s ease;
      overflow: hidden;

      /* 터치 드래그 UX */
      touch-action: none;
    }
    body.lensOn #lens{
      opacity: 1;
      pointer-events: auto;
    }

    /* 셀로판 질감 */
    #lens::before{
      content:"";
      position:absolute; inset:-24px;
      background:
        radial-gradient(circle at 20% 30%, rgba(255,255,255,.30), transparent 55%),
        radial-gradient(circle at 70% 60%, rgba(255,255,255,.18), transparent 50%),
        repeating-linear-gradient(25deg, rgba(255,255,255,.14) 0 2px, transparent 2px 8px);
      opacity:.35;
      mix-blend-mode: screen;
      pointer-events:none;
    }
    /* 점무늬 */
    #lens::after{
      content:"";
      position:absolute; inset:-10px;
      background: radial-gradient(rgba(0,0,0,.22) 1px, transparent 1.8px);
      background-size: 11px 11px;
      opacity:.10;
      mix-blend-mode: multiply;
      pointer-events:none;
    }

    /* 렌즈 가장자리 살짝 두껍게(유리 느낌) */
    .ring{
      position:absolute; inset:8px;
      border-radius: 999px;
      box-shadow: 0 0 0 1px rgba(0,0,0,.10) inset;
      pointer-events:none;
    }

    /* 작은 힌트(원하면 삭제) */
    #hint{
      position: fixed;
      left: 18px; bottom: 18px;
      font-family: var(--sans);
      font-size: 12px;
      opacity: .55;
      background: rgba(255,255,255,.88);
      border: 1px solid rgba(0,0,0,.10);
      padding: 6px 10px;
      border-radius: 999px;
      backdrop-filter: blur(10px);
      z-index: 9999;
    }
    body.lensOn #hint{ opacity:.25; }

    @media (prefers-reduced-motion: reduce){
      #lens{ transition:none; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>전유된 대화: 내 욕망으로 번역되는 타자의 목소리</h1>
      <p>우측 하단 스와치를 눌러 렌즈를 켜고, 렌즈를 손가락/마우스로 끌어 이동하세요. 렌즈 안에 들어온 “단어”만 강제 번역됩니다.</p>
    </header>
    <div id="content"></div>
  </div>

  <div id="swatch" aria-label="Toggle lens"><div class="inner"></div></div>
  <div id="lens" aria-label="Lens"><div class="ring"></div></div>
  <div id="hint">Lens: OFF</div>

  <script>
    // ✅ 원문을 길게 넣어도 OK
    const TEXT = `
They discovered the beauty of merchandise and started making it relentlessly.
After a time, there was so much merchandise that they had to build new houses to shelter and distribute it everywhere.
Once these stone houses had proliferated, they connected them to each other with tangled paths and gave them the name "city."
This is how little by little the forest disappeared from their land along with the game that inhabited it.

The napenaperi spirits want to keep the beauty of their mirror-land and protect it from epidemic fumes.
Bees are also xapiri; this is why their images spoke to me this way during my sleep.
`.trim();

    // ✅ “명사/핵심어”만 치환 (원하면 여기만 계속 다듬으면 됨)
    // 키는 단어 경계(\b) 포함해서 ‘단어’처럼 작동하게.
    const NOUN_MAP = [
      [/^forest$/i, "Asset"],
      [/^tree(s)?$/i, "Resource"],
      [/^spirit(s)?$/i, "IP"],
      [/^xapiri$/i, "Intangible"],
      [/^bee(s)?$/i, "Product"],
      [/^honey$/i, "Revenue"],
      [/^flower(s)?$/i, "Input"],
      [/^land$/i, "Property"],
      [/^knowledge$/i, "Patent"],
      [/^law$/i, "Policy"],
      [/^memory$/i, "Database"],
      [/^song(s)?$/i, "Content"],
      [/^image(s)?$/i, "Brand"],
      [/^medicine$/i, "Product"],
      [/^merchandise$/i, "Inventory"],
      [/^city|cities$/i, "Market"],
      [/^house|houses$/i, "Facility"],
      [/^garden|gardens$/i, "Production"],
      [/^game$/i, "Stock"],
    ];

    const content = document.getElementById("content");
    const lens = document.getElementById("lens");
    const swatch = document.getElementById("swatch");
    const hint = document.getElementById("hint");

    let lensOn = false;

    function escapeHtml(str){
      return str
        .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
        .replaceAll('"',"&quot;").replaceAll("'","&#039;");
    }

    // ✅ 텍스트를 “단어 토큰”으로 쪼개서 span으로 감싸기
    // 공백/줄바꿈/문장부호는 그대로 출력(토큰화하면서 보존)
    function renderTokenized(text){
      // 단어(알파벳/하이픈/아포스트로피 포함) vs 그 외로 분리
      const parts = text.split(/([A-Za-z]+(?:'[A-Za-z]+)?)/g);
      const frag = document.createDocumentFragment();

      for (const p of parts){
        if (!p) continue;
        if (/^[A-Za-z]+(?:'[A-Za-z]+)?$/.test(p)){
          const span = document.createElement("span");
          span.className = "w";
          span.dataset.orig = p;
          span.textContent = p;
          frag.appendChild(span);
        } else {
          frag.appendChild(document.createTextNode(p));
        }
      }
      content.textContent = ""; // clear
      content.appendChild(frag);
    }

    function translateWord(word){
      for (const [re,to] of NOUN_MAP){
        if (re.test(word)) return to;
      }
      return null;
    }

    renderTokenized(TEXT);

    const wordSpans = () => Array.from(content.querySelectorAll(".w"));

    // ✅ 렌즈 원형 안에 들어온 “단어”만 치환
    function updateLensEffect(){
      if (!lensOn) return;

      const lr = lens.getBoundingClientRect();
      const cx = lr.left + lr.width / 2;
      const cy = lr.top + lr.height / 2;
      const radius = lr.width / 2 - 12; // 가장자리 여유

      for (const sp of wordSpans()){
        const r = sp.getBoundingClientRect();
        const wx = r.left + r.width / 2;
        const wy = r.top + r.height / 2;

        // 단어 중심점이 렌즈 원 안에 있으면 적용
        const inside = ((wx - cx) ** 2 + (wy - cy) ** 2) <= (radius ** 2);

        if (inside){
          const orig = sp.dataset.orig || "";
          const t = translateWord(orig);
          if (t){
            if (!sp.classList.contains("ap") || sp.textContent !== t){
              sp.classList.add("ap");
              sp.textContent = t;
            }
          } else {
            // 치환 대상이 아니면 원문 유지
            if (sp.classList.contains("ap")){
              sp.classList.remove("ap");
              sp.textContent = orig;
            } else if (sp.textContent !== orig){
              sp.textContent = orig;
            }
          }
        } else {
          // 렌즈 밖이면 원문 복원
          const orig = sp.dataset.orig || "";
          if (sp.classList.contains("ap") || sp.textContent !== orig){
            sp.classList.remove("ap");
            sp.textContent = orig;
          }
        }
      }
    }

    // ---- 렌즈 토글
    function setLens(on){
      lensOn = on;
      document.body.classList.toggle("lensOn", on);
      hint.textContent = on ? "Lens: ON (drag)" : "Lens: OFF";
      if (!on){
        // 전부 원문 복원
        for (const sp of wordSpans()){
          sp.classList.remove("ap");
          sp.textContent = sp.dataset.orig || "";
        }
      } else {
        updateLensEffect();
      }
    }

    swatch.addEventListener("click", () => setLens(!lensOn));

    // ---- 렌즈 드래그: 렌즈 자체를 잡고 끌면 따라오게
    let dragging = false;
    let offsetX = 0, offsetY = 0;

    function moveLensTo(clientX, clientY){
      const w = lens.offsetWidth;
      const h = lens.offsetHeight;

      // 화면 밖으로 너무 나가지 않게 clamp (살짝은 나가도 괜찮으면 범위 늘려도 됨)
      const x = Math.max(-w*0.15, Math.min(window.innerWidth - w*0.85, clientX - offsetX));
      const y = Math.max(-h*0.15, Math.min(window.innerHeight - h*0.85, clientY - offsetY));

      lens.style.left = x + "px";
      lens.style.top  = y + "px";
      lens.style.transform = "translate(0,0)"; // 초기 중앙정렬 해제
      updateLensEffect();
    }

    lens.addEventListener("pointerdown", (e) => {
      if (!lensOn) return;
      dragging = true;
      const r = lens.getBoundingClientRect();
      offsetX = e.clientX - r.left;
      offsetY = e.clientY - r.top;
      lens.setPointerCapture(e.pointerId);
    });

    lens.addEventListener("pointermove", (e) => {
      if (!dragging) return;
      moveLensTo(e.clientX, e.clientY);
    });

    lens.addEventListener("pointerup", (e) => {
      dragging = false;
      try { lens.releasePointerCapture(e.pointerId); } catch {}
    });

    // 스크롤/리사이즈 시에도 갱신
    window.addEventListener("scroll", () => updateLensEffect(), { passive:true });
    window.addEventListener("resize", () => updateLensEffect());
  </script>
</body>
</html>
