<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Appropriation — Viral Lens (Goo + Readable Text)</title>
  <style>
    :root{
      --bg:#ffffff;
      --ink:#111;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;

      --lensSize: 200px;
      --fadeSeconds: 6.5;

      /* ✅ goo tuned to be “texture”, not “shape” */
      --blurPx: 4;        /* smaller blur = less melty */
      --thresh: 205;      /* higher = less merging */
      --front: 0.04;      /* thinner front swell */
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{ margin:0; background:var(--bg); color:var(--ink); overflow:hidden; }

    .stage{ position:fixed; inset:0; display:grid; place-items:center; padding:28px; }
    #sentence{
      width:min(1200px,92vw);
      text-align:center;
      font-family:var(--sans);
      font-weight:650;
      font-size:clamp(40px,6vw,96px);
      line-height:1.08;
      letter-spacing:-0.02em;
      user-select:none;
      position:relative;
      z-index:2;
    }

    /* micro motion for ORIGINAL words */
    .w{
      display:inline-block;
      padding:0 .06em;
      transform: translateZ(0);
      will-change: transform;

      animation-name: microFloat;
      animation-duration: var(--mfDur, 7.2s);
      animation-timing-function: ease-in-out;
      animation-iteration-count: infinite;
      animation-delay: var(--mfDelay, 0s);
    }
    /* discovered: hide original ink + stop motion */
    .w.hideInk{ color:transparent; animation:none; }

    @keyframes microFloat{
      0%   { transform: translate3d(0,0,0) rotate(0deg); }
      33%  { transform: translate3d(var(--mx, .55px), var(--my, -.45px), 0) rotate(var(--mr, .10deg)); }
      66%  { transform: translate3d(calc(var(--mx, .55px) * -0.65), calc(var(--my, -.45px) * -0.55), 0) rotate(calc(var(--mr, .10deg) * -0.65)); }
      100% { transform: translate3d(0,0,0) rotate(0deg); }
    }
    @media (prefers-reduced-motion: reduce){ .w{ animation:none !important; } }

    #blackout{ position:fixed; inset:0; background:#000; opacity:0; pointer-events:none; z-index:5; transition:opacity 90ms linear; }
    #overlay{ position:fixed; inset:0; pointer-events:none; z-index:6; }

    canvas.viral{
      position:absolute; left:0; top:0;
      transform: translate(-50%,-55%);
      opacity:0; transition:opacity 140ms linear;
    }
    canvas.viral.on{ opacity:1; }

    body.final #sentence{ opacity:0; transition:opacity 320ms ease; }

    #lens{
      position:fixed;
      width:var(--lensSize);
      height:var(--lensSize);
      border-radius:999px;
      left:72%;
      top:44%;
      transform:translate(-50%,-50%);
      z-index:10;
      pointer-events:auto;
      touch-action:none;
    }

    /* lens */
    #lens .glass{
      position:absolute;
      inset:0;
      border-radius:999px;
      overflow:hidden;
      background:
        radial-gradient(circle at 35% 28%,
          rgba(255,255,255,.65) 0%,
          rgba(255,255,255,.28) 26%,
          rgba(255,255,255,.10) 52%,
          rgba(0,0,0,.06) 78%,
          rgba(0,0,0,.10) 100%);
      backdrop-filter: blur(1.2px) brightness(1.06) contrast(1.06);
      -webkit-backdrop-filter: blur(1.2px) brightness(1.06) contrast(1.06);
      box-shadow:
        0 34px 90px rgba(0,0,0,.28),
        0 10px 22px rgba(0,0,0,.18),
        inset 0 22px 36px rgba(255,255,255,.55),
        inset 0 -30px 46px rgba(0,0,0,.22),
        inset 0 0 46px rgba(0,0,0,.14);
    }
    #lens .glass::before{
      content:"";
      position:absolute;
      inset:-55px;
      border-radius:999px;
      pointer-events:none;
      background:
        radial-gradient(circle at 30% 20%, rgba(255,255,255,.75), transparent 52%),
        radial-gradient(circle at 72% 78%, rgba(255,255,255,.20), transparent 60%),
        radial-gradient(circle at 52% 58%, rgba(255,255,255,.10), transparent 62%),
        linear-gradient(145deg, rgba(255,255,255,.16), transparent 64%);
      mix-blend-mode:screen;
      opacity:.70;
      filter: blur(0.4px);
    }
    #lens .glass::after{
      content:"";
      position:absolute;
      inset:0;
      border-radius:999px;
      pointer-events:none;
      background:
        radial-gradient(circle,
          rgba(255,255,255,.00) 58%,
          rgba(255,255,255,.14) 64%,
          rgba(0,0,0,.16) 78%,
          rgba(0,0,0,.26) 100%);
      box-shadow:
        inset 0 0 0 1px rgba(255,255,255,.10),
        inset 0 0 0 10px rgba(255,255,255,.05),
        inset 0 -14px 22px rgba(0,0,0,.18),
        inset 0 14px 22px rgba(255,255,255,.10);
    }

    .hint{
      position:fixed; left:16px; bottom:16px; z-index:20;
      font-family:var(--sans); font-size:12px; opacity:.65;
      background:rgba(255,255,255,.86);
      border:1px solid rgba(0,0,0,.08);
      padding:8px 10px; border-radius:999px;
      backdrop-filter: blur(4px);
      user-select:none;
    }
    body.final .hint{ display:none; }
  </style>
</head>
<body>
  <div class="stage"><div id="sentence"></div></div>
  <div id="blackout"></div>
  <div id="overlay"></div>

  <div id="lens"><div class="glass"></div></div>
  <div class="hint">Drag lens over: beauty / merchandise / making</div>

<script>
(() => {
  const TEXT = "Then they discovered the beauty of merchandise and started making it relentlessly.";
  const TARGETS = [
    { re: /^beauty$/i, out: "VALUATION" },
    { re: /^merchandise$/i, out: "COMMODITY" },
    { re: /^making$/i, out: "OPTIMIZING" },
  ];

  const sentence = document.getElementById("sentence");
  const overlay  = document.getElementById("overlay");
  const lens     = document.getElementById("lens");
  const blackout = document.getElementById("blackout");

  function cleanWord(w){ return w.replace(/[^\w']/g, ""); }
  function findTarget(word){
    const c = cleanWord(word);
    for (const t of TARGETS) if (t.re.test(c)) return { key:c.toLowerCase(), out:t.out };
    return null;
  }

  // sentence
  sentence.textContent = "";
  const words = TEXT.split(" ");
  words.forEach((w,i)=>{
    const sp=document.createElement("span");
    sp.className="w";
    sp.textContent=w;

    // micro motion params
    const dur = 6.2 + Math.random()*4.2;
    const delay = -(Math.random()*6.0);
    const mx = (Math.random()*1.4 - 0.70);
    const my = (Math.random()*1.2 - 0.60);
    const mr = (Math.random()*0.20 - 0.10);
    sp.style.setProperty("--mfDur", dur.toFixed(2)+"s");
    sp.style.setProperty("--mfDelay", delay.toFixed(2)+"s");
    sp.style.setProperty("--mx", mx.toFixed(2)+"px");
    sp.style.setProperty("--my", my.toFixed(2)+"px");
    sp.style.setProperty("--mr", mr.toFixed(3)+"deg");

    const hit=findTarget(w);
    if(hit){ sp.dataset.hit="1"; sp.dataset.key=hit.key; sp.dataset.out=hit.out; }

    sentence.appendChild(sp);
    if(i!==words.length-1) sentence.appendChild(document.createTextNode(" "));
  });

  // RNG helpers
  function hashStr(s){
    let h=2166136261;
    for(let i=0;i<s.length;i++){ h^=s.charCodeAt(i); h=Math.imul(h,16777619); }
    return h>>>0;
  }
  function makeRng(seed0){
    let seed = seed0>>>0;
    return function(){
      seed ^= seed<<13; seed ^= seed>>>17; seed ^= seed<<5;
      return (seed>>>0)/4294967295;
    }
  }

  function ensureCanvas(canvas, w, h){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(w*dpr);
    canvas.height= Math.floor(h*dpr);
    canvas.style.width = w+"px";
    canvas.style.height= h+"px";
    const ctx = canvas.getContext("2d");
    ctx.setTransform(dpr,0,0,dpr,0,0);
    return { ctx, dpr };
  }

  // measure + fit
  function measureTextBounds(text, font){
    const c = document.createElement("canvas");
    const ctx = c.getContext("2d");
    ctx.font = font;
    const m = ctx.measureText(text);
    const w = Math.ceil(m.width);
    const h = Math.ceil((m.actualBoundingBoxAscent || 0) + (m.actualBoundingBoxDescent || 0)) || 1;
    const ascent = Math.ceil(m.actualBoundingBoxAscent || h*0.75);
    return { w, h, ascent };
  }

  function precomputeParticles_FIT(text, targetW, targetH, seedKey){
    const rng = makeRng(hashStr(seedKey));
    const baseFontSize = 240;
    const fontFamily = getComputedStyle(document.body).getPropertyValue("--sans").trim() || "system-ui";
    const baseFont = `900 ${baseFontSize}px ${fontFamily}`;

    const base = measureTextBounds(text, baseFont);
    const padFactor = 0.86;
    const sx = (targetW * padFactor) / Math.max(1, base.w);
    const sy = (targetH * padFactor) / Math.max(1, base.h);
    const fitScale = Math.min(sx, sy);

    const fontSize = Math.max(18, Math.min(340, Math.floor(baseFontSize * fitScale)));
    const font = `900 ${fontSize}px ${fontFamily}`;
    const m2 = measureTextBounds(text, font);

    const pad = Math.round(Math.max(10, Math.min(34, Math.min(targetW, targetH) * 0.12)));
    const w = Math.ceil(targetW + pad*2);
    const h = Math.ceil(targetH + pad*2);

    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const c = document.createElement("canvas");
    c.width = Math.floor(w*dpr);
    c.height = Math.floor(h*dpr);
    const ctx = c.getContext("2d");
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.clearRect(0,0,w,h);

    // draw text into this local canvas (for sampling)
    ctx.font = font;
    ctx.textAlign="left";
    ctx.textBaseline="alphabetic";
    ctx.fillStyle="#000";

    const x = Math.floor((w - m2.w)/2);
    const y = Math.floor((h - m2.h)/2) + m2.ascent;
    ctx.fillText(text, x, y);

    const img = ctx.getImageData(0,0,c.width,c.height).data;

    // particles
    const pts = [];
    const samplingDensity = 4;
    for(let yy=0; yy<h; yy+=samplingDensity){
      for(let xx=0; xx<w; xx+=samplingDensity){
        const px = Math.floor(xx * dpr);
        const py = Math.floor(yy * dpr);
        const idx = (py * c.width + px) * 4;
        const a = img[idx+3];
        if(a > 128){
          const jitterX = (rng() - 0.5) * samplingDensity * 0.55;
          const jitterY = (rng() - 0.5) * samplingDensity * 0.55;
          pts.push({
            x: xx + jitterX,
            y: yy + jitterY,
            r0: 0.95 + rng()*0.65,   // ✅ much smaller = goo is texture
            ph: rng()*Math.PI*2,
            ax: 0.22 + rng()*0.18,
            ay: 0.20 + rng()*0.16,
            spd: 0.55 + rng()*0.60
          });
        }
      }
    }

    // infection order
    const seedCount = Math.min(4, Math.max(2, Math.floor(pts.length/900)));
    const seeds = [];
    for(let i=0;i<seedCount;i++) seeds.push(pts[Math.floor(rng()*pts.length)]);
    for(const p of pts){
      let d = Infinity;
      for(const s of seeds){
        const dx = p.x - s.x, dy = p.y - s.y;
        d = Math.min(d, Math.hypot(dx,dy));
      }
      p.d = d + (rng()-0.5)*6.0;
    }
    pts.sort((a,b)=>a.d-b.d);
    for(let i=0;i<pts.length;i++){
      pts[i].rank = i/(pts.length-1);
    }

    // return everything needed to render *actual* readable text on top
    return { pts, w, h, font, text, textX: x, textY: y };
  }

  // Goo render: circles -> blur -> threshold -> tint (below) + readable fillText (above)
  function gooRender(mainCtx, obj, t, color){
    const tt = t*0.001;
    const prog = obj.prog;

    const blurPx = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--blurPx")) || 4;
    const thresh = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--thresh")) || 205;
    const front  = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--front")) || 0.04;

    const off = obj.off;
    const offCtx = obj.offCtx;
    const ow = obj.offW, oh = obj.offH;

    offCtx.setTransform(1,0,0,1,0,0);
    offCtx.clearRect(0,0,ow,oh);

    const dx = Math.floor((ow - obj.data.w)/2);
    const dy = Math.floor((oh - obj.data.h)/2);

    // 1) draw mask circles
    offCtx.save();
    offCtx.translate(dx, dy);

    const wig = (1 - Math.min(1, prog*1.05)) * 0.45;
    offCtx.fillStyle = "#000";

    for(const p of obj.data.pts){
      if(p.rank > prog) continue;

      const edge = Math.max(0, 1 - Math.abs(p.rank - prog)/front);
      const swell = 1 + edge * (0.38 + 0.18*Math.sin(tt*5.2 + p.ph));

      const ox = Math.sin(tt*(0.9*p.spd) + p.ph) * p.ax * wig;
      const oy = Math.cos(tt*(0.8*p.spd) + p.ph) * p.ay * wig;

      const rr = p.r0 * swell;
      offCtx.beginPath();
      offCtx.arc(p.x + ox, p.y + oy, rr, 0, Math.PI*2);
      offCtx.fill();
    }

    // 2) spores (very subtle + low alpha so it won’t destroy letters)
    if(!obj.spores){
      const rng = makeRng(hashStr(obj.key + "::spores"));
      obj.spores = [];
      const n = 14;
      const cx = obj.data.w/2, cy = obj.data.h/2;
      for(let i=0;i<n;i++){
        const ang = rng()*Math.PI*2;
        const dist = 18 + rng()*Math.min(74, Math.min(obj.data.w, obj.data.h)*0.28);
        obj.spores.push({
          x: cx + Math.cos(ang)*dist,
          y: cy + Math.sin(ang)*dist,
          r: 0.85 + rng()*0.85,
          ph: rng()*Math.PI*2,
          spd: 0.8 + rng()*0.9
        });
      }
    }
    const spStrength = Math.max(0, Math.min(1, (prog - 0.22) / 0.65));
    if(spStrength > 0){
      offCtx.save();
      offCtx.globalAlpha = 0.35 * spStrength; // ✅ low impact
      for(const s of obj.spores){
        const drift = 0.6 + spStrength*1.3;
        const jx = Math.cos(tt*1.8*s.spd + s.ph) * drift;
        const jy = Math.sin(tt*1.6*s.spd + s.ph) * drift;
        const rr = s.r * (1 + 0.25*Math.sin(tt*4.0 + s.ph));
        offCtx.beginPath();
        offCtx.arc(s.x + jx, s.y + jy, rr, 0, Math.PI*2);
        offCtx.fill();
      }
      offCtx.restore();
    }

    offCtx.restore();

    // 3) blur mask
    const bctx = obj.blurCtx;
    bctx.setTransform(1,0,0,1,0,0);
    bctx.clearRect(0,0,ow,oh);
    bctx.filter = `blur(${blurPx}px)`;
    bctx.drawImage(off, 0, 0);
    bctx.filter = "none";

    // 4) threshold alpha (tight band)
    const img = bctx.getImageData(0,0,ow,oh);
    const d = img.data;

    const t0 = thresh;
    const t1 = Math.min(255, thresh + 18);

    for(let i=0;i<d.length;i+=4){
      const a = d[i+3];
      if(a <= t0) d[i+3] = 0;
      else if(a >= t1) d[i+3] = 255;
      else {
        const u = (a - t0) / (t1 - t0);
        d[i+3] = Math.floor(255 * u);
      }
      d[i]=0; d[i+1]=0; d[i+2]=0;
    }
    bctx.putImageData(img,0,0);

    // 5) tint goo
    offCtx.setTransform(1,0,0,1,0,0);
    offCtx.clearRect(0,0,ow,oh);
    offCtx.fillStyle = color;
    offCtx.fillRect(0,0,ow,oh);
    offCtx.globalCompositeOperation = "destination-in";
    offCtx.drawImage(obj.blur,0,0);
    offCtx.globalCompositeOperation = "source-over";

    // draw goo under
    mainCtx.drawImage(off, 0, 0);

    // 6) ✅ readable text on top (this is what fixes legibility)
    const textAlpha = Math.max(0, Math.min(1, (prog - 0.12) / 0.55));
    if(textAlpha > 0){
      mainCtx.save();
      mainCtx.globalAlpha = 0.92 * textAlpha;
      mainCtx.fillStyle = color;
      mainCtx.font = obj.data.font;
      mainCtx.textAlign = "left";
      mainCtx.textBaseline = "alphabetic";

      // subtle “organic” shimmer WITHOUT losing shape
      const shimmer = 0.35 * (1 - textAlpha) * Math.sin(tt*10.0);
      mainCtx.translate(dx + shimmer, dy);

      mainCtx.fillText(obj.data.text, obj.data.textX, obj.data.textY);

      // tiny “edge fatten” to fight blur perception
      mainCtx.globalAlpha = 0.25 * textAlpha;
      mainCtx.lineWidth = 1.0;
      mainCtx.strokeStyle = color;
      mainCtx.strokeText(obj.data.text, obj.data.textX, obj.data.textY);

      mainCtx.restore();
    }
  }

  // infection
  const spans = Array.from(sentence.querySelectorAll(".w"));
  const infected = new Map();
  let infectionStart = null;

  function ensureInfected(span){
    const key = span.dataset.key;
    if (infected.has(key)) return infected.get(key);

    const canvas = document.createElement("canvas");
    canvas.className = "viral";
    overlay.appendChild(canvas);

    const obj = {
      key,
      out: span.dataset.out,
      span,
      canvas,
      startedAt: performance.now(),
      prog: 0,
      data: null,
      lastTW: 0,
      lastTH: 0,

      off: document.createElement("canvas"),
      blur: document.createElement("canvas"),
      offCtx: null,
      blurCtx: null,
      offW: 0,
      offH: 0,
      spores: null,
    };
    infected.set(key, obj);
    if (!infectionStart) infectionStart = performance.now();
    return obj;
  }

  function lensCenter(){
    const r = lens.getBoundingClientRect();
    return { cx:r.left+r.width/2, cy:r.top+r.height/2, rad:r.width/2 };
  }
  function isHit(span, lensInfo){
    const r = span.getBoundingClientRect();
    const wx = r.left + r.width/2;
    const wy = r.top  + r.height/2;
    return ((wx-lensInfo.cx)**2 + (wy-lensInfo.cy)**2) <= (lensInfo.rad**2);
  }

  // drag lens
  let dragging=false, offX=0, offY=0;
  function setLensPos(x,y){
    const size = lens.getBoundingClientRect().width;
    const nx = Math.max(size*0.15, Math.min(window.innerWidth - size*0.15, x));
    const ny = Math.max(size*0.15, Math.min(window.innerHeight - size*0.15, y));
    lens.style.left = nx+"px";
    lens.style.top  = ny+"px";
  }
  lens.addEventListener("pointerdown",(e)=>{
    dragging=true;
    const r=lens.getBoundingClientRect();
    offX=e.clientX-(r.left+r.width/2);
    offY=e.clientY-(r.top+r.height/2);
    lens.setPointerCapture(e.pointerId);
  });
  lens.addEventListener("pointermove",(e)=>{
    if(!dragging) return;
    setLensPos(e.clientX-offX, e.clientY-offY);
  });
  lens.addEventListener("pointerup",(e)=>{
    dragging=false;
    try{ lens.releasePointerCapture(e.pointerId);}catch{}
  });
  setLensPos(window.innerWidth*0.74, window.innerHeight*0.44);

  function clamp01(x){ return Math.max(0, Math.min(1, x)); }

  function tick(t){
    const now = performance.now();
    const lensInfo = lensCenter();

    // trigger
    for(const sp of spans){
      if(sp.dataset.hit!=="1") continue;
      if(isHit(sp, lensInfo)){
        const obj=ensureInfected(sp);
        obj.canvas.classList.add("on");
      }
    }

    // render
    for(const obj of infected.values()){
      obj.prog = clamp01(Math.max(obj.prog, (now-obj.startedAt)/5200));

      // hide original ink once infection begins
      if(obj.prog > 0.10) obj.span.classList.add("hideInk");

      const r = obj.span.getBoundingClientRect();
      const cx = r.left + r.width/2;
      const cy = r.top  + r.height/2;

      const targetW = Math.max(10, r.width  * 1.05);
      const targetH = Math.max(10, r.height * 1.10);

      const canvasW = Math.max(240, targetW * 1.55);
      const canvasH = Math.max(160, targetH * 1.70);

      obj.canvas.style.left = cx+"px";
      obj.canvas.style.top  = cy+"px";
      obj.canvas.style.transform = "translate(-50%,-55%)";

      const cw = Math.round(canvasW);
      const ch = Math.round(canvasH);

      const tw = Math.round(targetW);
      const th = Math.round(targetH);
      if(!obj.data || obj.lastTW !== tw || obj.lastTH !== th){
        obj.lastTW = tw; obj.lastTH = th;
        obj.data = precomputeParticles_FIT(obj.out, tw, th, obj.key + ":" + obj.out);
        obj.spores = null;
      }

      const main = ensureCanvas(obj.canvas, cw, ch);
      const mainCtx = main.ctx;
      mainCtx.clearRect(0,0,cw,ch);

      if(obj.offW !== cw || obj.offH !== ch || !obj.offCtx || !obj.blurCtx){
        obj.offW = cw; obj.offH = ch;
        obj.off.width  = cw; obj.off.height = ch;
        obj.blur.width = cw; obj.blur.height = ch;
        obj.offCtx  = obj.off.getContext("2d", { willReadFrequently: true });
        obj.blurCtx = obj.blur.getContext("2d", { willReadFrequently: true });
      }

      const isFinal = document.body.classList.contains("final");
      const color = isFinal ? "#ffffff" : "#111111";

      gooRender(mainCtx, obj, t, color);
    }

    // blackout → final
    if(infectionStart){
      const seconds = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--fadeSeconds")) || 6.5;
      const globalProg = clamp01((now - infectionStart) / (seconds*1000));
      blackout.style.opacity = String(Math.pow(globalProg, 0.52));

      if(globalProg >= 0.995 && !document.body.classList.contains("final")){
        document.body.classList.add("final");
        blackout.style.opacity = "1";
        lens.style.display = "none";
      }
    }

    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  window.addEventListener("resize", ()=>{
    const r=lens.getBoundingClientRect();
    setLensPos(r.left+r.width/2, r.top+r.height/2);
  });
})();
</script>
</body>
</html>
