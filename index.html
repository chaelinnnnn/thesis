<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Appropriation Lens — Virus Type + Trace</title>
  <style>
    :root{
      --bg:#ffffff;
      --ink:#111;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    body{ margin:0; background:var(--bg); color:var(--ink); }

    .wrap{ width:min(920px, 92vw); margin:0 auto; padding:44px 16px 300px; }
    header{
      position: sticky; top: 0; z-index: 3;
      background: rgba(255,255,255,.92);
      border-bottom: 1px solid rgba(0,0,0,.08);
      padding: 10px 0 12px;
    }
    header h1{ margin:0; font-family:var(--sans); font-size:18px; font-weight:700; }
    header p{ margin:6px 0 0; font-size:13px; opacity:.72; }

    #content{
      margin-top: 16px;
      font-family: var(--mono);
      font-size: 16px;
      line-height: 1.95;
      white-space: pre-wrap;
      word-break: keep-all;
      letter-spacing: .01em;
    }

    /* 단어 토큰 */
    .w{
      display:inline;
      border-radius: 10px;
      padding: 0 2px;
      position: relative;
    }

    /* ─────────────────────────────────────────────
       ✅ "바이러스 타이포" = 치환된 단어만 적용
       - 외곽선 두께감(다중 text-shadow)
       - 울렁임( svg filter: displacement )
       - 점무늬/덩어리 배경(부드럽게)
       - 컬러는 var(--ap)로 주입
    ───────────────────────────────────────────── */
    .w.ap{
      --ap: rgba(0,0,0,.18);

      font-weight: 900;
      letter-spacing: .02em;

      /* 텍스트 컬러는 거의 검정 + 컬러는 그림자/배경에만 */
      color: #0b0b0b;

      /* 덩어리/외곽선 느낌 */
      text-shadow:
        1px 0   0 rgba(0,0,0,.42),
       -1px 0   0 rgba(0,0,0,.42),
        0  1px  0 rgba(0,0,0,.42),
        0 -1px  0 rgba(0,0,0,.42),
        2px 0   0 rgba(255,255,255,.85),
       -2px 0   0 rgba(255,255,255,.85),
        0  2px  0 rgba(255,255,255,.85),
        0 -2px  0 rgba(255,255,255,.85),
        0  0  14px var(--ap);

      /* 울렁임(바이러스/오염) */
      filter: url(#virusWarp);

      /* 살짝 “스티커”처럼 */
      padding: 0 6px;
      border-radius: 14px;
    }

    /* 치환 단어 뒤의 “콜로니(점무늬/덩어리)” */
    .w.ap::before{
      content:"";
      position:absolute;
      left:-10px; right:-10px;
      top: 50%;
      height: 1.3em;
      transform: translateY(-50%);
      border-radius: 999px;

      /* 레퍼런스처럼 점무늬/덩어리 질감 */
      background:
        radial-gradient(circle at 12% 35%, rgba(0,0,0,.22) 0 1.2px, transparent 1.3px),
        radial-gradient(circle at 26% 70%, rgba(0,0,0,.16) 0 1.1px, transparent 1.2px),
        radial-gradient(circle at 58% 40%, rgba(0,0,0,.14) 0 1.3px, transparent 1.4px),
        radial-gradient(circle at 78% 65%, rgba(0,0,0,.18) 0 1.0px, transparent 1.1px),
        radial-gradient(circle at 90% 40%, rgba(0,0,0,.12) 0 1.4px, transparent 1.5px),
        linear-gradient(90deg, rgba(0,0,0,.06), rgba(0,0,0,.00));

      opacity: .42;
      mix-blend-mode: multiply;
      pointer-events:none;

      /* 컬러 틴트(아주 약하게) */
      box-shadow: 0 0 0 999px color-mix(in srgb, transparent 82%, var(--ap) 18%);
      filter: url(#virusGrain);
    }

    /* 치환 단어 위에 “살짝 번짐” 레이어 */
    .w.ap::after{
      content:"";
      position:absolute;
      inset:-6px -8px;
      border-radius: 16px;
      background: color-mix(in srgb, transparent 86%, var(--ap) 14%);
      opacity: .22;
      filter: blur(1.5px);
      pointer-events:none;
    }

    /* 토글 스와치 */
    #swatch{
      position: fixed; right: 18px; bottom: 44px;
      width: 52px; height: 52px;
      border-radius: 18px;
      border: 1px solid rgba(0,0,0,.14);
      background: rgba(255,255,255,.92);
      box-shadow: 0 8px 30px rgba(0,0,0,.12);
      cursor: pointer; z-index: 9999;
      display:grid; place-items:center; user-select:none;
    }
    #swatch .inner{
      width: 18px; height: 18px; border-radius: 999px;
      background: rgba(0,0,0,.82);
      box-shadow: 0 0 0 6px rgba(0,0,0,.06), 0 0 0 1px rgba(0,0,0,.14) inset;
    }

    /* 렌즈 wrap */
    #lensWrap{
      position: fixed;
      inset: 0;
      z-index: 9998;
      opacity: 0;
      transition: opacity .16s ease;
      pointer-events: none;
    }
    body.lensOn #lensWrap{ opacity: 1; }

    /* 렌즈(유리/필름) */
    #lens{
      position: fixed;
      left: 50%;
      top: 58%;
      width: 420px;
      height: 420px;
      transform: translate(-50%,-50%);
      border-radius: 999px;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(0,0,0,.18);
      box-shadow:
        0 14px 40px rgba(0,0,0,.10),
        0 0 0 1px rgba(255,255,255,.75) inset;
      opacity: 0;
      pointer-events: none;
      transition: opacity .16s ease;
      touch-action: none;
      overflow: hidden;
    }
    body.lensOn #lens{
      opacity: 1;
      pointer-events: auto;
    }
    #lens::before{
      content:"";
      position:absolute; inset:-40px;
      background:
        radial-gradient(circle at 30% 25%, rgba(255,255,255,.55), transparent 45%),
        radial-gradient(circle at 70% 70%, rgba(255,255,255,.22), transparent 55%),
        linear-gradient(135deg, rgba(255,255,255,.18), transparent 60%);
      opacity:.35;
      mix-blend-mode: screen;
      pointer-events:none;
    }
    #lens::after{
      content:"";
      position:absolute; inset:10px;
      border-radius: 999px;
      box-shadow:
        0 0 0 1px rgba(0,0,0,.08) inset,
        0 -10px 25px rgba(255,255,255,.25) inset;
      pointer-events:none;
    }
    #handle{
      position:absolute;
      left: 50%;
      top: 50%;
      transform: translate(150px, 150px);
      width: 40px; height: 40px;
      border-radius: 999px;
      background: rgba(255,255,255,.78);
      border: 1px solid rgba(0,0,0,.10);
      box-shadow: 0 10px 28px rgba(0,0,0,.14);
      display:grid;
      place-items:center;
      pointer-events:none;
      opacity:.9;
    }
    #handle::before{
      content:"";
      width: 12px; height: 12px;
      border-radius: 999px;
      background: rgba(0,0,0,.82);
      box-shadow: 0 0 0 6px rgba(0,0,0,.05);
    }

    /* 하단 trace bar */
    #traceBar{
      position: fixed;
      left: 0;
      bottom: 0;
      width: 100%;
      height: 22px;
      background: rgba(255,255,255,.90);
      border-top: 1px solid rgba(0,0,0,.06);
      display: flex;
      align-items: center;
      gap: 2px;
      padding: 0 6px;
      z-index: 9997;
      pointer-events: none;
      overflow: hidden;
    }
    .trace{
      flex: 1;
      height: 6px;
      border-radius: 3px;
      opacity: .16;
      filter: saturate(70%);
    }

    #hint{
      position: fixed; left: 18px; bottom: 44px;
      font-family: var(--sans);
      font-size: 12px;
      opacity: .58;
      background: rgba(255,255,255,.92);
      border: 1px solid rgba(0,0,0,.10);
      padding: 6px 10px;
      border-radius: 999px;
      z-index: 9999;
      user-select: none;
      pointer-events: none;
    }
  </style>
</head>
<body>

  <!-- ✅ SVG 필터(바이러스 울렁임 + 그레인) -->
  <svg width="0" height="0" style="position:absolute">
    <filter id="virusWarp">
      <feTurbulence type="fractalNoise" baseFrequency="0.012" numOctaves="2" seed="7" result="noise"/>
      <feDisplacementMap in="SourceGraphic" in2="noise" scale="12" xChannelSelector="R" yChannelSelector="G"/>
    </filter>

    <filter id="virusGrain">
      <feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="1" seed="3" result="grain"/>
      <feColorMatrix type="matrix"
        values="
          0 0 0 0 0
          0 0 0 0 0
          0 0 0 0 0
          0 0 0 .25 0" />
    </filter>
  </svg>

  <div class="wrap">
    <header>
      <h1>전유된 대화: 내 욕망으로 번역되는 타자의 목소리</h1>
      <p>우측 하단 스와치로 렌즈를 켜고/끄세요. 렌즈 안 단어만 강제 번역되고, 치환된 단어는 “바이러스 타이포”로 나타납니다. 하단은 전유 흔적 색 침전.</p>
    </header>
    <div id="content"></div>
  </div>

  <div id="swatch" aria-label="Toggle lens"><div class="inner"></div></div>

  <div id="lensWrap" aria-hidden="true">
    <div id="lens" aria-label="Lens">
      <div id="handle" aria-hidden="true"></div>
    </div>
  </div>

  <div id="hint">Lens: OFF</div>
  <div id="traceBar" aria-hidden="true"></div>

  <script>
    const TEXT = `
They were the ones who put the tall stones of Omama’s house in place and created the first merchandise, paper skins, and medicine.

The napenaperi spirits want to keep the beauty of their mirror-land and protect it from epidemic fumes. Yet today’s white people no longer know how to take care of it, and they know nothing of these images, which are those of their ancestors.

In the past, their long-ago elders knew them and made them dance. They knew how to imitate their songs and build their spirit houses. But then those who were born after them began to create the cities. Little by little they stopped hearing these spirits’ words. Then the books made them forgetful, and they finally rejected them.

Bees are also xapiri; this is why their images spoke to me this way during my sleep. They wanted to tell me of their concern: “The white people truly lack wisdom. They must stop mistreating the trees in the forest. Soon there will be no more flowers to feed us and make honey.”

Cutting down trees is also destroying the bees’ paths through the forest. Without flowering trees, they will no longer know where to work, and they will flee from our land forever.

Then they discovered the beauty of merchandise and started making it relentlessly. After a time, there was so much merchandise that they had to build new houses to shelter and distribute it everywhere.

This is how little by little the forest disappeared from their land.
`.trim();

    // ✅ 10개 키워드 + 색
    const NOUN_MAP = [
      { re: /^forest$/i,     to: "Asset",      color: "#7b8a97" },
      { re: /^xapiri$/i,     to: "Intangible", color: "#8a7f92" },
      { re: /^bee(s)?$/i,    to: "Product",    color: "#7f8f86" },
      { re: /^honey$/i,      to: "Revenue",    color: "#8f7f7a" },
      { re: /^flower(s)?$/i, to: "Input",      color: "#8b8b7a" },
      { re: /^land$/i,       to: "Property",   color: "#7a8292" },
      { re: /^knowledge$/i,  to: "Patent",     color: "#7f7f8f" },
      { re: /^law$/i,        to: "Policy",     color: "#8a8a96" },
      { re: /^memory$/i,     to: "Database",   color: "#7f8790" },
      { re: /^medicine$/i,   to: "Product",    color: "#8b8080" },
    ];

    const content = document.getElementById("content");
    const lens = document.getElementById("lens");
    const swatch = document.getElementById("swatch");
    const hint = document.getElementById("hint");
    const traceBar = document.getElementById("traceBar");

    let lensOn = false;

    function renderTokenized(text){
      const parts = text.split(/([A-Za-z]+(?:'[A-Za-z]+)?)/g);
      const frag = document.createDocumentFragment();
      for (const p of parts){
        if (!p) continue;
        if (/^[A-Za-z]+(?:'[A-Za-z]+)?$/.test(p)){
          const span = document.createElement("span");
          span.className = "w";
          span.dataset.orig = p;
          span.textContent = p;
          frag.appendChild(span);
        } else {
          frag.appendChild(document.createTextNode(p));
        }
      }
      content.textContent = "";
      content.appendChild(frag);
    }

    function lookupWord(word){
      for (const entry of NOUN_MAP){
        if (entry.re.test(word)) return entry;
      }
      return null;
    }

    function addTrace(color){
      const t = document.createElement("div");
      t.className = "trace";
      t.style.background = color;
      traceBar.appendChild(t);
      const MAX = 90;
      while (traceBar.children.length > MAX){
        traceBar.removeChild(traceBar.firstChild);
      }
    }

    renderTokenized(TEXT);
    const wordSpans = () => Array.from(content.querySelectorAll(".w"));

    // 렌즈 안 단어만 치환 + 바이러스 타이포 + trace
    function updateLensEffect(){
      if (!lensOn) return;

      const lr = lens.getBoundingClientRect();
      const cx = lr.left + lr.width / 2;
      const cy = lr.top + lr.height / 2;
      const radius = lr.width / 2;

      for (const sp of wordSpans()){
        const r = sp.getBoundingClientRect();
        const wx = r.left + r.width / 2;
        const wy = r.top + r.height / 2;
        const inside = ((wx - cx) ** 2 + (wy - cy) ** 2) <= (radius ** 2);

        const orig = sp.dataset.orig || "";

        if (inside){
          const entry = lookupWord(orig);
          if (entry){
            // 중복 trace 방지: "처음 치환되는 순간"에만 축적
            if (sp.textContent !== entry.to || !sp.classList.contains("ap")){
              sp.classList.add("ap");
              sp.textContent = entry.to;

              // ✅ 컬러를 CSS 변수로 주입(바이러스 배경/글로우에 사용)
              sp.style.setProperty("--ap", entry.color);

              addTrace(entry.color);
            }
          } else {
            if (sp.textContent !== orig || sp.classList.contains("ap")){
              sp.classList.remove("ap");
              sp.textContent = orig;
              sp.style.removeProperty("--ap");
            }
          }
        } else {
          if (sp.textContent !== orig || sp.classList.contains("ap")){
            sp.classList.remove("ap");
            sp.textContent = orig;
            sp.style.removeProperty("--ap");
          }
        }
      }
    }

    function setLens(on){
      lensOn = on;
      document.body.classList.toggle("lensOn", on);
      hint.textContent = on ? "Lens: ON (drag)" : "Lens: OFF";
      if (!on){
        for (const sp of wordSpans()){
          sp.classList.remove("ap");
          sp.textContent = sp.dataset.orig || "";
          sp.style.removeProperty("--ap");
        }
      } else {
        updateLensEffect();
      }
    }

    swatch.addEventListener("click", () => setLens(!lensOn));

    // 드래그
    let dragging = false;
    let offsetX = 0, offsetY = 0;

    function moveLensTo(clientX, clientY){
      const w = lens.offsetWidth;
      const h = lens.offsetHeight;

      const x = Math.max(-w*0.25, Math.min(window.innerWidth - w*0.75, clientX - offsetX));
      const y = Math.max(-h*0.25, Math.min(window.innerHeight - h*0.75, clientY - offsetY));

      lens.style.left = x + "px";
      lens.style.top  = y + "px";
      lens.style.transform = "translate(0,0)";
      updateLensEffect();
    }

    lens.addEventListener("pointerdown", (e) => {
      if (!lensOn) return;
      dragging = true;
      const r = lens.getBoundingClientRect();
      offsetX = e.clientX - r.left;
      offsetY = e.clientY - r.top;
      lens.setPointerCapture(e.pointerId);
    });

    lens.addEventListener("pointermove", (e) => {
      if (!dragging) return;
      moveLensTo(e.clientX, e.clientY);
    });

    lens.addEventListener("pointerup", (e) => {
      dragging = false;
      try { lens.releasePointerCapture(e.pointerId); } catch {}
    });

    window.addEventListener("scroll", () => updateLensEffect(), { passive:true });
    window.addEventListener("resize", () => updateLensEffect());
  </script>
</body>
</html>
