<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Appropriation Lens — Final</title>
  <style>
    :root{
      --bg:#ffffff;
      --ink:#111;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    body{ margin:0; background:var(--bg); color:var(--ink); }

    .wrap{ width:min(920px, 92vw); margin:0 auto; padding:44px 16px 260px; }
    header{
      position: sticky; top: 0; z-index: 3;
      background: rgba(255,255,255,.92);
      border-bottom: 1px solid rgba(0,0,0,.08);
      padding: 10px 0 12px;
    }
    header h1{ margin:0; font-family:var(--sans); font-size:18px; font-weight:700; }
    header p{ margin:6px 0 0; font-size:13px; opacity:.72; }

    #content{
      margin-top: 16px;
      font-family: var(--mono);
      font-size: 16px;
      line-height: 1.95;
      white-space: pre-wrap;
      word-break: keep-all;
      letter-spacing: .01em;
    }

    /* 단어 토큰 */
    .w{ display:inline; border-radius: 8px; padding: 0 2px; }

    /* 렌즈 안에서 치환된 단어만 표시(무채색) */
    .w.ap{
      background: rgba(0,0,0,.06);
      box-shadow: 0 0 0 1px rgba(0,0,0,.10) inset;
      font-weight: 750;
      color:#000;
    }

    /* 우하단 스와치(렌즈 가동 토글) — 유지 */
    #swatch{
      position: fixed; right: 18px; bottom: 18px;
      width: 52px; height: 52px;
      border-radius: 18px;
      border: 1px solid rgba(0,0,0,.14);
      background: rgba(255,255,255,.92);
      box-shadow: 0 8px 30px rgba(0,0,0,.12);
      cursor: pointer; z-index: 9999;
      display:grid; place-items:center; user-select:none;
    }
    #swatch .inner{
      width: 18px; height: 18px; border-radius: 999px;
      background: rgba(0,0,0,.82);
      box-shadow: 0 0 0 6px rgba(0,0,0,.06), 0 0 0 1px rgba(0,0,0,.14) inset;
    }

    /* ✅ 렌즈(원형) — 기능은 유지, ‘보임’만 투명하게 */
    #lens{
      position: fixed;
      left: 50%;
      top: 58%;

      /* ✅ 렌즈 크기 키움 */
      width: 420px;
      height: 420px;

      transform: translate(-50%,-50%);
      border-radius: 999px;

      /* ✅ 거의 투명(중요) */
      background: transparent;
      border: 1px solid rgba(0,0,0,.06); /* 원하면 0으로 */
      box-shadow: none;
      backdrop-filter: none;

      z-index: 9998;

      /* ✅ OFF면 안 보이고/못 잡음 (가동 토글 유지) */
      opacity: 0;
      pointer-events: none;

      transition: opacity .16s ease;
      touch-action: none; /* 모바일 드래그 */
    }
    body.lensOn #lens{
      opacity: 1;
      pointer-events: auto;
    }

    /* 조작할 때만 살짝 보이게(원하면 삭제) */
    #lens:active{ border-color: rgba(0,0,0,.16); }

    /* 상태 표시(원하면 삭제 가능) */
    #hint{
      position: fixed; left: 18px; bottom: 18px;
      font-family: var(--sans);
      font-size: 12px;
      opacity: .58;
      background: rgba(255,255,255,.92);
      border: 1px solid rgba(0,0,0,.10);
      padding: 6px 10px;
      border-radius: 999px;
      z-index: 9999;
      user-select: none;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>전유된 대화: 내 욕망으로 번역되는 타자의 목소리</h1>
      <p>우측 하단 스와치로 렌즈를 켜고/끄세요. 렌즈가 켜진 상태에서만, 원형 안에 들어온 “단어(명사 키워드)”가 강제 번역됩니다.</p>
    </header>
    <div id="content"></div>
  </div>

  <div id="swatch" aria-label="Toggle lens"><div class="inner"></div></div>
  <div id="lens" aria-label="Lens"></div>
  <div id="hint">Lens: OFF</div>

  <script>
    // ✅ 원문(더 길게). 필요하면 아래에 계속 붙여도 됨.
    const TEXT = `
They were the ones who put the tall stones of Omama’s house in place and created the first merchandise, paper skins, and medicine.

The napenaperi spirits want to keep the beauty of their mirror-land and protect it from epidemic fumes. Yet today’s white people no longer know how to take care of it, and they know nothing of these images, which are those of their ancestors.

In the past, their long-ago elders knew them and made them dance. They knew how to imitate their songs and build their spirit houses. But then those who were born after them began to create the cities. Little by little they stopped hearing these spirits’ words. Then the books made them forgetful, and they finally rejected them.

Bees are also xapiri; this is why their images spoke to me this way during my sleep. They wanted to tell me of their concern: “The white people truly lack wisdom. They must stop mistreating the trees in the forest. Soon there will be no more flowers to feed us and make honey.”

Cutting down trees is also destroying the bees’ paths through the forest. Without flowering trees, they will no longer know where to work, and they will flee from our land forever.

Then they discovered the beauty of merchandise and started making it relentlessly. After a time, there was so much merchandise that they had to build new houses to shelter and distribute it everywhere. Once these stone houses had proliferated, they connected them to each other with tangled paths and gave them the name “city.”

This is how little by little the forest disappeared from their land along with the game that inhabited it. They only kept a few living animals in pens and some other dead ones in glass cases so their children could contemplate them as souvenirs.
`.trim();

    // ✅ 치환 전 → 치환 후 (요청한 명단 그대로)
    const NOUN_MAP = [
      [/^forest$/i, "Asset"],
      [/^tree(s)?$/i, "Resource"],
      [/^spirit(s)?$/i, "IP"],
      [/^xapiri$/i, "Intangible"],
      [/^bee(s)?$/i, "Product"],
      [/^honey$/i, "Revenue"],
      [/^flower(s)?$/i, "Input"],
      [/^land$/i, "Property"],
      [/^knowledge$/i, "Patent"],
      [/^law$/i, "Policy"],
      [/^memory$/i, "Database"],
      [/^song(s)?$/i, "Content"],
      [/^image(s)?$/i, "Brand"],
      [/^medicine$/i, "Product"],
      [/^merchandise$/i, "Inventory"],
      [/^(city|cities)$/i, "Market"],
      [/^(house|houses)$/i, "Facility"],
      [/^(garden|gardens)$/i, "Production"],
      [/^game$/i, "Stock"],
    ];

    const content = document.getElementById("content");
    const lens = document.getElementById("lens");
    const swatch = document.getElementById("swatch");
    const hint = document.getElementById("hint");

    let lensOn = false;

    // 텍스트를 단어 토큰(span)으로 쪼개기: 공백/구두점/줄바꿈은 보존
    function renderTokenized(text){
      const parts = text.split(/([A-Za-z]+(?:'[A-Za-z]+)?)/g);
      const frag = document.createDocumentFragment();

      for (const p of parts){
        if (!p) continue;
        if (/^[A-Za-z]+(?:'[A-Za-z]+)?$/.test(p)){
          const span = document.createElement("span");
          span.className = "w";
          span.dataset.orig = p;
          span.textContent = p;
          frag.appendChild(span);
        } else {
          frag.appendChild(document.createTextNode(p));
        }
      }
      content.textContent = "";
      content.appendChild(frag);
    }

    function translateWord(word){
      for (const [re,to] of NOUN_MAP){
        if (re.test(word)) return to;
      }
      return null;
    }

    renderTokenized(TEXT);

    const wordSpans = () => Array.from(content.querySelectorAll(".w"));

    // ✅ 렌즈 원형 내부에 들어온 단어만 치환
    function updateLensEffect(){
      if (!lensOn) return;

      const lr = lens.getBoundingClientRect();
      const cx = lr.left + lr.width / 2;
      const cy = lr.top + lr.height / 2;
      const radius = lr.width / 2;

      for (const sp of wordSpans()){
        const r = sp.getBoundingClientRect();
        const wx = r.left + r.width / 2;
        const wy = r.top + r.height / 2;

        const inside = ((wx - cx) ** 2 + (wy - cy) ** 2) <= (radius ** 2);

        const orig = sp.dataset.orig || "";
        if (inside){
          const t = translateWord(orig);
          if (t){
            if (sp.textContent !== t || !sp.classList.contains("ap")){
              sp.classList.add("ap");
              sp.textContent = t;
            }
          } else {
            if (sp.textContent !== orig || sp.classList.contains("ap")){
              sp.classList.remove("ap");
              sp.textContent = orig;
            }
          }
        } else {
          if (sp.textContent !== orig || sp.classList.contains("ap")){
            sp.classList.remove("ap");
            sp.textContent = orig;
          }
        }
      }
    }

    // ✅ 렌즈 “가동 토글(ON/OFF)” — 그대로 유지
    function setLens(on){
      lensOn = on;
      document.body.classList.toggle("lensOn", on);
      hint.textContent = on ? "Lens: ON (drag the circle)" : "Lens: OFF";

      if (!on){
        // 끄면 전부 원문 복원
        for (const sp of wordSpans()){
          sp.classList.remove("ap");
          sp.textContent = sp.dataset.orig || "";
        }
      } else {
        updateLensEffect();
      }
    }

    swatch.addEventListener("click", () => setLens(!lensOn));

    // ✅ 렌즈 드래그: 렌즈 자체를 잡고 이동
    let dragging = false;
    let offsetX = 0, offsetY = 0;

    function moveLensTo(clientX, clientY){
      const w = lens.offsetWidth;
      const h = lens.offsetHeight;

      // 화면 밖으로 살짝 나가도 되게 여유 clamp
      const x = Math.max(-w*0.25, Math.min(window.innerWidth - w*0.75, clientX - offsetX));
      const y = Math.max(-h*0.25, Math.min(window.innerHeight - h*0.75, clientY - offsetY));

      lens.style.left = x + "px";
      lens.style.top  = y + "px";
      lens.style.transform = "translate(0,0)"; // 초기 중앙 정렬 해제
      updateLensEffect();
    }

    lens.addEventListener("pointerdown", (e) => {
      if (!lensOn) return;
      dragging = true;
      const r = lens.getBoundingClientRect();
      offsetX = e.clientX - r.left;
      offsetY = e.clientY - r.top;
      lens.setPointerCapture(e.pointerId);
    });

    lens.addEventListener("pointermove", (e) => {
      if (!dragging) return;
      moveLensTo(e.clientX, e.clientY);
    });

    lens.addEventListener("pointerup", (e) => {
      dragging = false;
      try { lens.releasePointerCapture(e.pointerId); } catch {}
    });

    // 스크롤/리사이즈 때도 계속 맞춰서 갱신
    window.addEventListener("scroll", () => updateLensEffect(), { passive:true });
    window.addEventListener("resize", () => updateLensEffect());
  </script>
</body>
</html>
