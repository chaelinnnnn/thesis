<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Appropriation Lens — PNG Overlay (Stable)</title>
  <style>
    :root{
      --bg:#ffffff;
      --ink:#111;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    body{ margin:0; background:var(--bg); color:var(--ink); }

    .wrap{ width:min(920px, 92vw); margin:0 auto; padding:44px 16px 220px; }
    header{
      position: sticky; top: 0; z-index: 3;
      background: rgba(255,255,255,.92);
      border-bottom: 1px solid rgba(0,0,0,.08);
      padding: 10px 0 12px;
    }
    header h1{ margin:0; font-family:var(--sans); font-size:18px; font-weight:700; }
    header p{ margin:6px 0 0; font-size:13px; opacity:.72; }

    #content{
      margin-top: 16px;
      font-family: var(--mono);
      font-size: 16px;
      line-height: 1.95;
      white-space: pre-wrap;
      word-break: keep-all;
      letter-spacing: .01em;
    }
    .w{ display:inline; position:relative; padding:0 2px; border-radius:10px; }

    /* 렌즈 안 매치된 단어: 글자 숨김 + 흰색 덮개로 잔상 제거 */
    .w.hiddenInk{ color: transparent; text-shadow:none; }
    .w.hiddenInk::before{
      content:"";
      position:absolute;
      left:-8px; right:-8px;
      top:50%;
      height: 1.45em;
      transform: translateY(-50%);
      background: rgba(255,255,255,1);
      border-radius: 12px;
      z-index: 1;
    }
    .w.hiddenInk{ z-index: 2; }

    /* PNG 레이어 */
    #pngLayer{
      position: fixed;
      inset: 0;
      z-index: 9996;
      pointer-events: none;
    }

    /* ✅ 렌즈 안에 있는 동안 "항상 선명" + 깜빡임 방지(캐싱) */
    .pngWord{
      position: absolute;
      transform-origin: left bottom;
      opacity: 0;                /* 기본은 숨김 */
      visibility: hidden;
      pointer-events: none;
      user-select: none;

      will-change: transform, left, top, width, height, opacity;
      filter: drop-shadow(0 18px 34px rgba(0,0,0,.26));
      transition: opacity .08s linear; /* 출현만 부드럽게 */
    }
    .pngWord.on{
      opacity: 1;
      visibility: visible;
      animation: drift 3.2s ease-in-out infinite;
    }

    /* 더 살아있는 움직임 */
    @keyframes drift{
      0%,100%{ transform: translate(var(--dx,0px), var(--dy,0px)) rotate(var(--rot,0deg)) skewX(var(--sk,0deg)); }
      50%{ transform: translate(calc(var(--dx,0px) + 3px), calc(var(--dy,0px) - 3px)) rotate(calc(var(--rot,0deg) + 1.2deg)) skewX(calc(var(--sk,0deg) + 1deg)); }
    }

    /* 토글 스와치 */
    #swatch{
      position: fixed; right: 18px; bottom: 18px;
      width: 52px; height: 52px;
      border-radius: 18px;
      border: 1px solid rgba(0,0,0,.14);
      background: rgba(255,255,255,.92);
      box-shadow: 0 8px 30px rgba(0,0,0,.12);
      cursor: pointer; z-index: 9999;
      display:grid; place-items:center; user-select:none;
    }
    #swatch .inner{
      width: 18px; height: 18px; border-radius: 999px;
      background: rgba(0,0,0,.82);
      box-shadow: 0 0 0 6px rgba(0,0,0,.06), 0 0 0 1px rgba(0,0,0,.14) inset;
    }

    /* 렌즈 */
    #lensWrap{ position:fixed; inset:0; z-index:9998; opacity:0; transition:opacity .16s ease; pointer-events:none; }
    body.lensOn #lensWrap{ opacity:1; }

    #lens{
      position: fixed;
      left: 50%; top: 58%;
      width: 480px; height: 480px;
      transform: translate(-50%,-50%);
      border-radius: 999px;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(0,0,0,.18);
      box-shadow: 0 14px 40px rgba(0,0,0,.10), 0 0 0 1px rgba(255,255,255,.75) inset;
      opacity:0; pointer-events:none;
      transition: opacity .16s ease;
      touch-action:none;
      overflow:hidden;
    }
    body.lensOn #lens{ opacity:1; pointer-events:auto; }

    #lens::before{
      content:""; position:absolute; inset:-40px;
      background:
        radial-gradient(circle at 30% 25%, rgba(255,255,255,.55), transparent 45%),
        radial-gradient(circle at 70% 70%, rgba(255,255,255,.22), transparent 55%),
        linear-gradient(135deg, rgba(255,255,255,.18), transparent 60%);
      opacity:.35; mix-blend-mode: screen; pointer-events:none;
    }
    #lens::after{
      content:""; position:absolute; inset:10px; border-radius:999px;
      box-shadow: 0 0 0 1px rgba(0,0,0,.08) inset, 0 -10px 25px rgba(255,255,255,.25) inset;
      pointer-events:none;
    }

    #handle{
      position:absolute; left:50%; top:50%;
      transform: translate(180px, 180px);
      width:40px; height:40px; border-radius:999px;
      background: rgba(255,255,255,.78);
      border: 1px solid rgba(0,0,0,.10);
      box-shadow: 0 10px 28px rgba(0,0,0,.14);
      display:grid; place-items:center;
      pointer-events:none; opacity:.9;
    }
    #handle::before{
      content:""; width:12px; height:12px; border-radius:999px;
      background: rgba(0,0,0,.82);
      box-shadow: 0 0 0 6px rgba(0,0,0,.05);
    }

    #hint{
      position: fixed; left:18px; bottom:18px;
      font-family: var(--sans);
      font-size: 12px;
      opacity:.58;
      background: rgba(255,255,255,.92);
      border: 1px solid rgba(0,0,0,.10);
      padding: 6px 10px;
      border-radius: 999px;
      z-index: 9999;
      user-select:none;
      pointer-events:none;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>전유된 대화: 내 욕망으로 번역되는 타자의 목소리</h1>
      <p>렌즈 ON일 때만, 렌즈 안 키워드는 텍스트를 완전히 가리고 PNG 바이러스 글자로 “안정적으로” 나타납니다.</p>
    </header>
    <div id="content"></div>
  </div>

  <div id="pngLayer" aria-hidden="true"></div>

  <div id="swatch" aria-label="Toggle lens"><div class="inner"></div></div>
  <div id="lensWrap" aria-hidden="true">
    <div id="lens" aria-label="Lens">
      <div id="handle" aria-hidden="true"></div>
    </div>
  </div>

  <div id="hint">Lens: OFF</div>

  <script>
    const TEXT = `
They were the ones who put the tall stones of Omama’s house in place and created the first merchandise, paper skins, and medicine.

The napenaperi spirits want to keep the beauty of their mirror-land and protect it from epidemic fumes. Yet today’s white people no longer know how to take care of it, and they know nothing of these images, which are those of their ancestors.

In the past, their long-ago elders knew them and made them dance. They knew how to imitate their songs and build their spirit houses. But then those who were born after them began to create the cities. Little by little they stopped hearing these spirits’ words. Then the books made them forgetful, and they finally rejected them.

Bees are also xapiri; this is why their images spoke to me this way during my sleep. They wanted to tell me of their concern: “The white people truly lack wisdom. They must stop mistreating the trees in the forest. Soon there will be no more flowers to feed us and make honey.”

This is how little by little the forest disappeared from their land.
`.trim();

    // ✅ 루트에 PNG가 있는 구조(스크린샷 기준)
    const PNG_MAP = [
      { re: /^forest$/i, png: "./asset.png" },
      { re: /^xapiri$/i, png: "./intangible.png" },
      // 필요시 추가:
      // { re: /^bee(s)?$/i,    png: "./product.png" },
      // { re: /^honey$/i,      png: "./revenue.png" },
      // { re: /^flower(s)?$/i, png: "./input.png" },
      // { re: /^medicine$/i,   png: "./product2.png" },
    ];

    const content = document.getElementById("content");
    const lens = document.getElementById("lens");
    const swatch = document.getElementById("swatch");
    const hint = document.getElementById("hint");
    const pngLayer = document.getElementById("pngLayer");

    let lensOn = false;

    // ✅ span -> img 캐시 (삭제하지 않고 재사용)
    const imgBySpan = new Map();
    const activeSpanSet = new Set();

    function renderTokenized(text){
      const parts = text.split(/([A-Za-z]+(?:'[A-Za-z]+)?)/g);
      const frag = document.createDocumentFragment();
      for (const p of parts){
        if (!p) continue;
        if (/^[A-Za-z]+(?:'[A-Za-z]+)?$/.test(p)){
          const span = document.createElement("span");
          span.className = "w";
          span.dataset.orig = p;
          span.textContent = p;
          frag.appendChild(span);
        } else {
          frag.appendChild(document.createTextNode(p));
        }
      }
      content.textContent = "";
      content.appendChild(frag);
    }

    function lookupPng(word){
      for (const entry of PNG_MAP){
        if (entry.re.test(word)) return entry;
      }
      return null;
    }

    renderTokenized(TEXT);
    const wordSpans = () => Array.from(content.querySelectorAll(".w"));

    function getOrCreateImgForSpan(span, entry){
      let img = imgBySpan.get(span);
      if (img) return img;

      img = document.createElement("img");
      img.className = "pngWord";
      img.src = entry.png;
      img.alt = "";
      img.draggable = false;
      img.onerror = () => console.warn("PNG load failed:", entry.png);
      pngLayer.appendChild(img);

      imgBySpan.set(span, img);
      return img;
    }

    // ✅ 깜빡임 방지: requestAnimationFrame으로 업데이트 스로틀
    let rafPending = false;
    function scheduleUpdate(){
      if (!lensOn) return;
      if (rafPending) return;
      rafPending = true;
      requestAnimationFrame(() => {
        rafPending = false;
        updateLensEffect();
      });
    }

    function updateLensEffect(){
      if (!lensOn) return;

      const lr = lens.getBoundingClientRect();
      const cx = lr.left + lr.width / 2;
      const cy = lr.top + lr.height / 2;
      const radius = lr.width / 2;

      // 이번 프레임에서 활성화된 span 추적
      activeSpanSet.clear();

      for (const sp of wordSpans()){
        const r = sp.getBoundingClientRect();
        const wx = r.left + r.width / 2;
        const wy = r.top + r.height / 2;
        const inside = ((wx - cx) ** 2 + (wy - cy) ** 2) <= (radius ** 2);

        const orig = sp.dataset.orig || "";

        if (inside){
          const entry = lookupPng(orig);
          if (entry){
            sp.classList.add("hiddenInk");
            activeSpanSet.add(sp);

            const img = getOrCreateImgForSpan(sp, entry);
            img.classList.add("on");

            // ✅ 더 크게 (최대 3.35) + 단어 길이 보정
            const len = orig.length;
            const base = 2.85;
            const boost = Math.max(0, 9 - len) * 0.08;
            const scale = Math.min(3.35, base + boost);

            img.style.left = r.left + "px";
            img.style.top  = r.top + "px";
            img.style.width  = (r.width * scale) + "px";
            img.style.height = (r.height * scale) + "px";

            // ✅ 덮어쓰기 위치(위/왼쪽)
            const dx = -r.width  * (scale - 1) * 0.32;
            const dy = -r.height * (scale - 1) * 0.78;

            // ✅ 각 이미지마다 고유 왜곡/움직임 값(한 번 정하면 유지)
            if (!img.dataset.seeded){
              const rot = (Math.random() * 2 - 1) * 3.6;
              const skew = (Math.random() * 2 - 1) * 3.0;
              img.style.setProperty("--rot", rot + "deg");
              img.style.setProperty("--sk", skew + "deg");
              img.dataset.seeded = "1";
            }

            // 위치는 매 프레임 업데이트(스크롤/드래그 대응)
            img.style.setProperty("--dx", dx + "px");
            img.style.setProperty("--dy", dy + "px");

          } else {
            sp.classList.remove("hiddenInk");
          }
        } else {
          sp.classList.remove("hiddenInk");
        }
      }

      // ✅ 활성화되지 않은(렌즈 밖) img는 숨김만(삭제 X)
      for (const [sp, img] of imgBySpan.entries()){
        if (!activeSpanSet.has(sp)){
          img.classList.remove("on");
        }
      }
    }

    function setLens(on){
      lensOn = on;
      document.body.classList.toggle("lensOn", on);
      hint.textContent = on ? "Lens: ON (drag)" : "Lens: OFF";

      if (!on){
        // 텍스트 복구 + 이미지 전부 숨김
        for (const sp of wordSpans()) sp.classList.remove("hiddenInk");
        for (const img of imgBySpan.values()) img.classList.remove("on");
      } else {
        scheduleUpdate();
      }
    }

    swatch.addEventListener("click", () => setLens(!lensOn));

    // 렌즈 드래그
    let dragging = false;
    let offsetX = 0, offsetY = 0;

    function moveLensTo(clientX, clientY){
      const w = lens.offsetWidth;
      const h = lens.offsetHeight;
      const x = Math.max(-w*0.25, Math.min(window.innerWidth - w*0.75, clientX - offsetX));
      const y = Math.max(-h*0.25, Math.min(window.innerHeight - h*0.75, clientY - offsetY));
      lens.style.left = x + "px";
      lens.style.top  = y + "px";
      lens.style.transform = "translate(0,0)";
      scheduleUpdate();
    }

    lens.addEventListener("pointerdown", (e) => {
      if (!lensOn) return;
      dragging = true;
      const r = lens.getBoundingClientRect();
      offsetX = e.clientX - r.left;
      offsetY = e.clientY - r.top;
      lens.setPointerCapture(e.pointerId);
    });

    lens.addEventListener("pointermove", (e) => {
      if (!dragging) return;
      moveLensTo(e.clientX, e.clientY);
    });

    lens.addEventListener("pointerup", (e) => {
      dragging = false;
      try { lens.releasePointerCapture(e.pointerId); } catch {}
    });

    window.addEventListener("scroll", () => scheduleUpdate(), { passive:true });
    window.addEventListener("resize", () => scheduleUpdate());
  </script>
</body>
</html>
