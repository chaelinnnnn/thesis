<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Appropriation — Viral Lens (Readable Blobs)</title>
  <style>
    :root{
      --bg:#ffffff;
      --ink:#111;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      --lensSize: 520px;
      --fadeSeconds: 6.5; /* faster to black */
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{ margin:0; background:var(--bg); color:var(--ink); overflow:hidden; }

    .stage{ position:fixed; inset:0; display:grid; place-items:center; padding:28px; }
    #sentence{
      width:min(1200px,92vw);
      text-align:center;
      font-family:var(--sans);
      font-weight:650;
      font-size:clamp(40px,6vw,96px);
      line-height:1.08;
      letter-spacing:-0.02em;
      user-select:none;
      position:relative;
      z-index:2;
    }
    .w{ display:inline-block; padding:0 .06em; }
    .w.hideInk{ color:transparent; }

    #blackout{ position:fixed; inset:0; background:#000; opacity:0; pointer-events:none; z-index:5; transition:opacity 90ms linear; }
    #overlay{ position:fixed; inset:0; pointer-events:none; z-index:6; }

    canvas.viral{
      position:absolute; left:0; top:0;
      transform: translate(-50%,-55%);
      opacity:0; transition:opacity 140ms linear;
    }
    canvas.viral.on{ opacity:1; }

    body.final #sentence{ opacity:0; transition:opacity 320ms ease; }

    #lens{
      position:fixed; width:var(--lensSize); height:var(--lensSize); border-radius:999px;
      left:72%; top:44%; transform:translate(-50%,-50%);
      z-index:10; pointer-events:auto; touch-action:none;
    }
    #lens .glass{
      position:absolute; inset:0; border-radius:999px; overflow:hidden;
      box-shadow:
        0 24px 70px rgba(0,0,0,.18),
        0 0 0 2px rgba(0,0,0,.18),
        0 0 0 10px rgba(255,255,255,.65) inset,
        0 -18px 34px rgba(0,0,0,.10) inset;
      background: rgba(255,255,255,.02);
    }
    #lens .glass::before{
      content:""; position:absolute; inset:-40px;
      background:
        radial-gradient(circle at 30% 22%, rgba(255,255,255,.70), transparent 48%),
        radial-gradient(circle at 78% 74%, rgba(255,255,255,.25), transparent 58%),
        linear-gradient(135deg, rgba(255,255,255,.18), transparent 60%);
      opacity:.55; mix-blend-mode:screen; pointer-events:none;
    }
    #lens .glass::after{
      content:""; position:absolute; inset:14px; border-radius:999px;
      box-shadow: 0 0 0 1px rgba(0,0,0,.10) inset, 0 0 0 18px rgba(255,255,255,.08) inset;
      pointer-events:none;
    }
    #lensHandle{
      position:absolute; width:46px; height:46px; border-radius:999px;
      right:26px; bottom:26px;
      background:rgba(255,255,255,.78);
      border:1px solid rgba(0,0,0,.12);
      box-shadow:0 12px 30px rgba(0,0,0,.14);
      display:grid; place-items:center;
      pointer-events:none;
    }
    #lensHandle::before{
      content:""; width:12px; height:12px; border-radius:999px;
      background:rgba(0,0,0,.82);
      box-shadow:0 0 0 7px rgba(0,0,0,.06);
    }

    .hint{
      position:fixed; left:16px; bottom:16px; z-index:20;
      font-family:var(--sans); font-size:12px; opacity:.65;
      background:rgba(255,255,255,.86);
      border:1px solid rgba(0,0,0,.08);
      padding:8px 10px; border-radius:999px;
      backdrop-filter: blur(4px);
      user-select:none;
    }
    body.final .hint{ display:none; }
  </style>
</head>
<body>
  <div class="stage"><div id="sentence"></div></div>
  <div id="blackout"></div>
  <div id="overlay"></div>

  <div id="lens">
    <div class="glass"></div>
    <div id="lensHandle"></div>
  </div>

  <div class="hint">Drag lens over: beauty / merchandise / making</div>

<script>
(() => {
  const TEXT = "Then they discovered the beauty of merchandise and started making it relentlessly.";
  const TARGETS = [
    { re: /^beauty$/i, out: "VALUATION" },
    { re: /^merchandise$/i, out: "COMMODITY" },
    { re: /^making$/i, out: "OPTIMIZING" },
  ];

  const sentence = document.getElementById("sentence");
  const overlay  = document.getElementById("overlay");
  const lens     = document.getElementById("lens");
  const blackout = document.getElementById("blackout");

  function cleanWord(w){ return w.replace(/[^\w']/g, ""); }
  function findTarget(word){
    const c = cleanWord(word);
    for (const t of TARGETS) if (t.re.test(c)) return { key:c.toLowerCase(), out:t.out };
    return null;
  }

  // sentence (keep spacing correct)
  sentence.textContent = "";
  const words = TEXT.split(" ");
  words.forEach((w,i)=>{
    const sp=document.createElement("span");
    sp.className="w";
    sp.textContent=w;
    const hit=findTarget(w);
    if(hit){ sp.dataset.hit="1"; sp.dataset.key=hit.key; sp.dataset.out=hit.out; }
    sentence.appendChild(sp);
    if(i!==words.length-1) sentence.appendChild(document.createTextNode(" "));
  });

  // RNG
  function hashStr(s){
    let h=2166136261;
    for(let i=0;i<s.length;i++){ h^=s.charCodeAt(i); h=Math.imul(h,16777619); }
    return h>>>0;
  }
  function makeRng(seed0){
    let seed = seed0>>>0;
    return function(){
      seed ^= seed<<13; seed ^= seed>>>17; seed ^= seed<<5;
      return (seed>>>0)/4294967295;
    }
  }

  function ensureCanvas(canvas, w, h){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(w*dpr);
    canvas.height= Math.floor(h*dpr);
    canvas.style.width = w+"px";
    canvas.style.height= h+"px";
    const ctx = canvas.getContext("2d");
    ctx.setTransform(dpr,0,0,dpr,0,0);
    return ctx;
  }

  // mask
  function buildMask(text, w, h, font){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const c = document.createElement("canvas");
    c.width = Math.floor(w*dpr);
    c.height= Math.floor(h*dpr);
    const ctx = c.getContext("2d");
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.clearRect(0,0,w,h);
    ctx.font = font;
    ctx.textAlign="center";
    ctx.textBaseline="middle";
    ctx.fillStyle="#000";
    ctx.fillText(text, w/2, h/2);
    const img = ctx.getImageData(0,0,c.width,c.height).data;
    return { img, mw:c.width, mh:c.height, dpr };
  }
  function alphaAt(mask, x, y, iw, ih){
    const px = Math.floor(Math.max(0, Math.min(iw-1, x)) * mask.dpr);
    const py = Math.floor(Math.max(0, Math.min(ih-1, y)) * mask.dpr);
    const idx = (py*mask.mw + px)*4;
    return mask.img[idx+3];
  }
  function edgeScore(mask, x, y, iw, ih){
    const a0 = alphaAt(mask, x, y, iw, ih);
    const s = 2.4;
    const a1 = alphaAt(mask, x+s, y,   iw, ih);
    const a2 = alphaAt(mask, x-s, y,   iw, ih);
    const a3 = alphaAt(mask, x,   y+s, iw, ih);
    const a4 = alphaAt(mask, x,   y-s, iw, ih);
    const dif = (Math.abs(a0-a1)+Math.abs(a0-a2)+Math.abs(a0-a3)+Math.abs(a0-a4)) / (4*255);
    return dif;
  }

  // ✅ IMPROVED: More readable particle placement
  function precomputeParticles_POISSON(text, w, h, seedKey){
    const rng = makeRng(hashStr(seedKey));

    const pad = Math.round(Math.max(64, Math.min(140, Math.min(w,h) * 0.28)));
    const iw = w - pad*2;
    const ih = h - pad*2;

    const fontSize = Math.max(34, Math.min(170, Math.floor(ih*0.82)));
    const font = `900 ${fontSize}px ${getComputedStyle(document.body).getPropertyValue("--sans") || "system-ui"}`;
    const mask = buildMask(text, iw, ih, font);

    // ✅ MUCH LOWER density - only outline particles
    const targetPts = Math.floor((iw*ih) / 400);  // drastically reduced
    const maxAttempts = targetPts * 20;

    // ✅ MUCH LARGER spacing between particles
    const minDistEdge = 8.5;  // outline only
    const minDistCore = 15.0; // very sparse core
    const cell = minDistEdge;
    const gw = Math.ceil(iw / cell);
    const gh = Math.ceil(ih / cell);
    const grid = new Array(gw*gh).fill(-1);

    function gridIndex(x,y){
      const gx = Math.floor(x / cell);
      const gy = Math.floor(y / cell);
      return gy*gw + gx;
    }

    function okDistance(x,y,minD,pts){
      const gx = Math.floor(x / cell);
      const gy = Math.floor(y / cell);
      const r = Math.ceil(minD / cell);
      for(let yy=Math.max(0,gy-r); yy<=Math.min(gh-1,gy+r); yy++){
        for(let xx=Math.max(0,gx-r); xx<=Math.min(gw-1,gx+r); xx++){
          const id = grid[yy*gw+xx];
          if(id<0) continue;
          const p = pts[id];
          const dx=x-p.x, dy=y-p.y;
          if(dx*dx+dy*dy < minD*minD) return false;
        }
      }
      return true;
    }

    function radius(rng, isEdge){
      // ✅ Smaller, more uniform particles
      const u = rng();
      const base = isEdge ? 0.8 : 1.0;
      const span = isEdge ? 1.2 : 1.5;
      let r = base + (1 - Math.pow(u, 3.5)) * span;
      if (rng() < 0.03) r *= 1.15;
      return r;
    }

    const pts = [];
    let tries = 0;

    while(pts.length < targetPts && tries < maxAttempts){
      tries++;

      const x = rng()*iw;
      const y = rng()*ih;

      const a = alphaAt(mask, x, y, iw, ih);
      if (a < 28) continue;

      const inside = a/255;
      const e = edgeScore(mask, x, y, iw, ih);

      // ✅ ONLY edges - completely kill interior
      const edgeBias = Math.min(1, e*8.0);  // very strong edge detection
      
      // Accept ONLY if it's an edge
      if (edgeBias < 0.4) continue;  // reject non-edges immediately
      
      let pKeep = edgeBias * 0.95;  // keep most edges
      if (inside > 0.85) pKeep *= 0.05;  // almost no interior
      if (rng() > pKeep) continue;

      const minD = (edgeBias > 0.35) ? minDistEdge : minDistCore;
      if(!okDistance(x,y,minD,pts)) continue;

      // accept
      const id = pts.length;
      pts.push({
        x: x + pad,
        y: y + pad,
        r0: radius(rng, edgeBias > 0.35),
        ph: rng()*Math.PI*2,
        pulse: 0.010 + rng()*0.018,
        blob: 2 + (rng()<0.45 ? 1 : 0)
      });

      grid[gridIndex(x,y)] = id;
    }

    return pts;
  }

  // draw "blob" (2~3 overlapping circles) -> virus-like but readable
  function drawBlob(ctx, x, y, r, rngVal, blobCount){
    for(let i=0;i<blobCount;i++){
      const ang = (i/blobCount)*Math.PI*2 + rngVal*0.8;
      const rr = r*(0.78 + (i===0?0.35:0.15));
      const ox = Math.cos(ang) * r*0.28;
      const oy = Math.sin(ang) * r*0.22;
      ctx.beginPath();
      ctx.arc(x+ox, y+oy, rr, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function render(ctx, pts, t, color){
    ctx.fillStyle = color;
    const tt = t*0.001;
    for(const p of pts){
      const rr = p.r0 * (1 + Math.sin(tt*0.55 + p.ph) * p.pulse);
      drawBlob(ctx, p.x, p.y, rr, p.ph, p.blob);
    }
  }

  // infection
  const spans = Array.from(sentence.querySelectorAll(".w"));
  const infected = new Map();
  let infectionStart = null;

  function ensureInfected(span){
    const key = span.dataset.key;
    if (infected.has(key)) return infected.get(key);

    const canvas = document.createElement("canvas");
    canvas.className = "viral";
    overlay.appendChild(canvas);

    const obj = {
      key,
      out: span.dataset.out,
      span,
      canvas,
      startedAt: performance.now(),
      prog: 0,
      particles: null,
      lastW: 0,
      lastH: 0
    };
    infected.set(key, obj);
    if (!infectionStart) infectionStart = performance.now();
    return obj;
  }

  function lensCenter(){
    const r = lens.getBoundingClientRect();
    return { cx:r.left+r.width/2, cy:r.top+r.height/2, rad:r.width/2 };
  }
  function isHit(span, lensInfo){
    const r = span.getBoundingClientRect();
    const wx = r.left + r.width/2;
    const wy = r.top  + r.height/2;
    return ((wx-lensInfo.cx)**2 + (wy-lensInfo.cy)**2) <= (lensInfo.rad**2);
  }

  // drag lens
  let dragging=false, offX=0, offY=0;
  function setLensPos(x,y){
    const size = lens.getBoundingClientRect().width;
    const nx = Math.max(size*0.15, Math.min(window.innerWidth - size*0.15, x));
    const ny = Math.max(size*0.15, Math.min(window.innerHeight - size*0.15, y));
    lens.style.left = nx+"px";
    lens.style.top  = ny+"px";
  }
  lens.addEventListener("pointerdown",(e)=>{
    dragging=true;
    const r=lens.getBoundingClientRect();
    offX=e.clientX-(r.left+r.width/2);
    offY=e.clientY-(r.top+r.height/2);
    lens.setPointerCapture(e.pointerId);
  });
  lens.addEventListener("pointermove",(e)=>{
    if(!dragging) return;
    setLensPos(e.clientX-offX, e.clientY-offY);
  });
  lens.addEventListener("pointerup",(e)=>{
    dragging=false;
    try{ lens.releasePointerCapture(e.pointerId);}catch{}
  });
  setLensPos(window.innerWidth*0.74, window.innerHeight*0.44);

  function clamp01(x){ return Math.max(0, Math.min(1, x)); }

  function tick(t){
    const now = performance.now();
    const lensInfo = lensCenter();

    // trigger
    for(const sp of spans){
      if(sp.dataset.hit!=="1") continue;
      if(isHit(sp, lensInfo)){
        const obj=ensureInfected(sp);
        sp.classList.add("hideInk");
        obj.canvas.classList.add("on");
      }
    }

    // render infected canvases
    for(const obj of infected.values()){
      obj.prog = clamp01(Math.max(obj.prog, (now-obj.startedAt)/6500));

      const r = obj.span.getBoundingClientRect();
      const cx = r.left + r.width/2;
      const cy = r.top  + r.height/2;

      const scale = 1.08 + 0.08*obj.prog;

      const w = Math.max(320, r.width  * (scale * 1.85));
      const h = Math.max(180, r.height * (scale * 1.60));

      obj.canvas.style.left = cx+"px";
      obj.canvas.style.top  = cy+"px";
      obj.canvas.style.transform = "translate(-50%,-55%)";

      const wInt = Math.round(w), hInt = Math.round(h);
      if (!obj.particles || obj.lastW !== wInt || obj.lastH !== hInt){
        obj.lastW = wInt; obj.lastH = hInt;
        obj.particles = precomputeParticles_POISSON(obj.out, wInt, hInt, obj.key + ":" + obj.out);
      }

      const ctx = ensureCanvas(obj.canvas, wInt, hInt);
      ctx.clearRect(0,0,wInt,hInt);

      const isFinal = document.body.classList.contains("final");
      render(ctx, obj.particles, t, isFinal ? "#ffffff" : "#111111");
    }

    // blackout → final
    if(infectionStart){
      const seconds = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--fadeSeconds")) || 6.5;
      const globalProg = clamp01((now - infectionStart) / (seconds*1000));
      blackout.style.opacity = String(Math.pow(globalProg, 0.52));

      if(globalProg >= 0.995 && !document.body.classList.contains("final")){
        document.body.classList.add("final");
        blackout.style.opacity = "1";
        lens.style.display = "none";
      }
    }

    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  window.addEventListener("resize", ()=>{
    const r=lens.getBoundingClientRect();
    setLensPos(r.left+r.width/2, r.top+r.height/2);
  });
})();
</script>
</body>
</html>
