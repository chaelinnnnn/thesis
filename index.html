<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Appropriation — Viral Lens (Blob Text)</title>
  <style>
    :root{
      --bg:#ffffff;
      --ink:#111;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      --lensSize: 200px;
      --fadeSeconds: 6.5;
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{ margin:0; background:var(--bg); color:var(--ink); overflow:hidden; }

    .stage{ position:fixed; inset:0; display:grid; place-items:center; padding:28px; }
    #sentence{
      width:min(1200px,92vw);
      text-align:center;
      font-family:var(--sans);
      font-weight:650;
      font-size:clamp(40px,6vw,96px);
      line-height:1.08;
      letter-spacing:-0.02em;
      user-select:none;
      position:relative;
      z-index:2;
    }
    .w{ display:inline-block; padding:0 .06em; }
    .w.hideInk{ color:transparent; }

    #blackout{ position:fixed; inset:0; background:#000; opacity:0; pointer-events:none; z-index:5; transition:opacity 90ms linear; }
    #overlay{ position:fixed; inset:0; pointer-events:none; z-index:6; }

    /* ✅ Blob SVG overlay for discovered words */
    svg.blobWord{
      position:absolute;
      left:0; top:0;
      transform: translate(-50%,-55%);
      opacity:0;
      transition: opacity 140ms linear;
      pointer-events:none;
    }
    svg.blobWord.on{ opacity:1; }

    body.final #sentence{ opacity:0; transition:opacity 320ms ease; }

    #lens{
      position:fixed;
      width:var(--lensSize);
      height:var(--lensSize);
      border-radius:999px;
      left:72%;
      top:44%;
      transform:translate(-50%,-50%);
      z-index:10;
      pointer-events:auto;
      touch-action:none;
    }

    /* ✅ lens: thicker rim + real glass feel */
    #lens .glass{
      position:absolute;
      inset:0;
      border-radius:999px;
      overflow:hidden;

      background:
        radial-gradient(circle at 35% 28%,
          rgba(255,255,255,.65) 0%,
          rgba(255,255,255,.28) 26%,
          rgba(255,255,255,.10) 52%,
          rgba(0,0,0,.06) 78%,
          rgba(0,0,0,.10) 100%);

      backdrop-filter: blur(1.2px) brightness(1.06) contrast(1.06);
      -webkit-backdrop-filter: blur(1.2px) brightness(1.06) contrast(1.06);

      box-shadow:
        0 34px 90px rgba(0,0,0,.28),
        0 10px 22px rgba(0,0,0,.18),
        inset 0 22px 36px rgba(255,255,255,.55),
        inset 0 -30px 46px rgba(0,0,0,.22),
        inset 0 0 46px rgba(0,0,0,.14);
    }
    #lens .glass::before{
      content:"";
      position:absolute;
      inset:-55px;
      border-radius:999px;
      pointer-events:none;
      background:
        radial-gradient(circle at 30% 20%, rgba(255,255,255,.75), transparent 52%),
        radial-gradient(circle at 72% 78%, rgba(255,255,255,.20), transparent 60%),
        radial-gradient(circle at 52% 58%, rgba(255,255,255,.10), transparent 62%),
        linear-gradient(145deg, rgba(255,255,255,.16), transparent 64%);
      mix-blend-mode:screen;
      opacity:.70;
      filter: blur(0.4px);
    }
    #lens .glass::after{
      content:"";
      position:absolute;
      inset:0;
      border-radius:999px;
      pointer-events:none;
      background:
        radial-gradient(circle,
          rgba(255,255,255,.00) 58%,
          rgba(255,255,255,.14) 64%,
          rgba(0,0,0,.16) 78%,
          rgba(0,0,0,.26) 100%);
      box-shadow:
        inset 0 0 0 1px rgba(255,255,255,.10),
        inset 0 0 0 10px rgba(255,255,255,.05),
        inset 0 -14px 22px rgba(0,0,0,.18),
        inset 0 14px 22px rgba(255,255,255,.10);
    }

    .hint{
      position:fixed; left:16px; bottom:16px; z-index:20;
      font-family:var(--sans); font-size:12px; opacity:.65;
      background:rgba(255,255,255,.86);
      border:1px solid rgba(0,0,0,.08);
      padding:8px 10px; border-radius:999px;
      backdrop-filter: blur(4px);
      user-select:none;
    }
    body.final .hint{ display:none; }
  </style>
</head>
<body>
  <div class="stage"><div id="sentence"></div></div>
  <div id="blackout"></div>
  <div id="overlay"></div>

  <div id="lens">
    <div class="glass"></div>
  </div>

  <div class="hint">Drag lens over: beauty / merchandise / making</div>

<script>
(() => {
  const TEXT = "Then they discovered the beauty of merchandise and started making it relentlessly.";
  const TARGETS = [
    { re: /^beauty$/i, out: "VALUATION" },
    { re: /^merchandise$/i, out: "COMMODITY" },
    { re: /^making$/i, out: "OPTIMIZING" },
  ];

  const sentence = document.getElementById("sentence");
  const overlay  = document.getElementById("overlay");
  const lens     = document.getElementById("lens");
  const blackout = document.getElementById("blackout");

  function cleanWord(w){ return w.replace(/[^\w']/g, ""); }
  function findTarget(word){
    const c = cleanWord(word);
    for (const t of TARGETS) if (t.re.test(c)) return { key:c.toLowerCase(), out:t.out };
    return null;
  }

  // sentence
  sentence.textContent = "";
  const words = TEXT.split(" ");
  words.forEach((w,i)=>{
    const sp=document.createElement("span");
    sp.className="w";
    sp.textContent=w;
    const hit=findTarget(w);
    if(hit){ sp.dataset.hit="1"; sp.dataset.key=hit.key; sp.dataset.out=hit.out; }
    sentence.appendChild(sp);
    if(i!==words.length-1) sentence.appendChild(document.createTextNode(" "));
  });

  // deterministic-ish id
  function hashStr(s){
    let h=2166136261;
    for(let i=0;i<s.length;i++){ h^=s.charCodeAt(i); h=Math.imul(h,16777619); }
    return (h>>>0);
  }

  function lensCenter(){
    const r = lens.getBoundingClientRect();
    return { cx:r.left+r.width/2, cy:r.top+r.height/2, rad:r.width/2 };
  }
  function isHit(span, lensInfo){
    const r = span.getBoundingClientRect();
    const wx = r.left + r.width/2;
    const wy = r.top  + r.height/2;
    return ((wx-lensInfo.cx)**2 + (wy-lensInfo.cy)**2) <= (lensInfo.rad**2);
  }

  // ✅ Create the blob SVG (video-like) — replaces particle style entirely
  function makeBlobSVG(text, uniq){
    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(svgNS, "svg");
    svg.classList.add("blobWord");

    // Make it big enough; we'll size it dynamically in tick
    svg.setAttribute("width", "600");
    svg.setAttribute("height", "260");
    svg.setAttribute("viewBox", "0 0 600 260");

    const defs = document.createElementNS(svgNS, "defs");

    // Filter: turbulence -> displacement -> blur -> threshold(goo) -> outline-ish
    const filter = document.createElementNS(svgNS, "filter");
    const fid = "blob_" + uniq;
    filter.setAttribute("id", fid);
    filter.setAttribute("x", "-20%");
    filter.setAttribute("y", "-20%");
    filter.setAttribute("width", "140%");
    filter.setAttribute("height", "140%");
    filter.setAttribute("color-interpolation-filters", "sRGB");

    const turb = document.createElementNS(svgNS, "feTurbulence");
    turb.setAttribute("type", "fractalNoise");
    turb.setAttribute("baseFrequency", "0.012");
    turb.setAttribute("numOctaves", "2");
    turb.setAttribute("seed", String((uniq % 97) + 3));
    turb.setAttribute("result", "noise");

    // animate baseFrequency slightly (subtle organic motion)
    const animBF = document.createElementNS(svgNS, "animate");
    animBF.setAttribute("attributeName", "baseFrequency");
    animBF.setAttribute("dur", "3.8s");
    animBF.setAttribute("repeatCount", "indefinite");
    animBF.setAttribute("values", "0.011;0.013;0.011");
    turb.appendChild(animBF);

    const disp = document.createElementNS(svgNS, "feDisplacementMap");
    disp.setAttribute("in", "SourceGraphic");
    disp.setAttribute("in2", "noise");
    disp.setAttribute("scale", "18");
    disp.setAttribute("xChannelSelector", "R");
    disp.setAttribute("yChannelSelector", "G");
    disp.setAttribute("result", "warped");

    // animate displacement scale (super subtle)
    const animSc = document.createElementNS(svgNS, "animate");
    animSc.setAttribute("attributeName", "scale");
    animSc.setAttribute("dur", "2.6s");
    animSc.setAttribute("repeatCount", "indefinite");
    animSc.setAttribute("values", "16;20;16");
    disp.appendChild(animSc);

    const blur = document.createElementNS(svgNS, "feGaussianBlur");
    blur.setAttribute("in", "warped");
    blur.setAttribute("stdDeviation", "1.25");
    blur.setAttribute("result", "blurred");

    // "goo" threshold via color matrix (high contrast)
    const cm = document.createElementNS(svgNS, "feColorMatrix");
    cm.setAttribute("in", "blurred");
    cm.setAttribute("type", "matrix");
    cm.setAttribute("values",
      "18 0  0  0 -9 " +
      "0  18 0  0 -9 " +
      "0  0  18 0 -9 " +
      "0  0  0  1  0"
    );
    cm.setAttribute("result", "goo");

    // Outline-ish: dilate then composite out to get edge
    const dil = document.createElementNS(svgNS, "feMorphology");
    dil.setAttribute("in", "goo");
    dil.setAttribute("operator", "dilate");
    dil.setAttribute("radius", "2.2");
    dil.setAttribute("result", "dilated");

    const edge = document.createElementNS(svgNS, "feComposite");
    edge.setAttribute("in", "dilated");
    edge.setAttribute("in2", "goo");
    edge.setAttribute("operator", "out");
    edge.setAttribute("result", "edge");

    // color the edge
    const edgeColor = document.createElementNS(svgNS, "feColorMatrix");
    edgeColor.setAttribute("in", "edge");
    edgeColor.setAttribute("type", "matrix");
    // edge black
    edgeColor.setAttribute("values",
      "0 0 0 0 0 " +
      "0 0 0 0 0 " +
      "0 0 0 0 0 " +
      "0 0 0 1 0"
    );
    edgeColor.setAttribute("result", "edgeBlack");

    // Merge: edge + goo fill
    const merge = document.createElementNS(svgNS, "feMerge");
    const m1 = document.createElementNS(svgNS, "feMergeNode");
    m1.setAttribute("in", "edgeBlack");
    const m2 = document.createElementNS(svgNS, "feMergeNode");
    m2.setAttribute("in", "goo");
    merge.appendChild(m1);
    merge.appendChild(m2);

    filter.appendChild(turb);
    filter.appendChild(disp);
    filter.appendChild(blur);
    filter.appendChild(cm);
    filter.appendChild(dil);
    filter.appendChild(edge);
    filter.appendChild(edgeColor);
    filter.appendChild(merge);

    defs.appendChild(filter);
    svg.appendChild(defs);

    // Group with filter
    const g = document.createElementNS(svgNS, "g");
    g.setAttribute("filter", `url(#${fid})`);

    // Fill (match your page ink, not the old particle style)
    const t = document.createElementNS(svgNS, "text");
    t.setAttribute("x", "50%");
    t.setAttribute("y", "50%");
    t.setAttribute("text-anchor", "middle");
    t.setAttribute("dominant-baseline", "middle");
    t.setAttribute("fill", getComputedStyle(document.documentElement).getPropertyValue("--ink") || "#111");
    t.setAttribute("font-family", getComputedStyle(document.documentElement).getPropertyValue("--sans") || "system-ui");
    t.setAttribute("font-weight", "900");
    t.textContent = text;

    g.appendChild(t);
    svg.appendChild(g);

    // store references for resizing later
    svg._textNode = t;

    return svg;
  }

  // infection
  const spans = Array.from(sentence.querySelectorAll(".w"));
  const infected = new Map();
  let infectionStart = null;

  function ensureInfected(span){
    const key = span.dataset.key;
    if (infected.has(key)) return infected.get(key);

    const uniq = hashStr(key + ":" + span.dataset.out);
    const svg = makeBlobSVG(span.dataset.out, uniq);
    overlay.appendChild(svg);

    const obj = {
      key,
      out: span.dataset.out,
      span,
      svg,
      startedAt: performance.now(),
      prog: 0,
      lastW: 0,
      lastH: 0
    };
    infected.set(key, obj);
    if (!infectionStart) infectionStart = performance.now();
    return obj;
  }

  // drag lens
  let dragging=false, offX=0, offY=0;
  function setLensPos(x,y){
    const size = lens.getBoundingClientRect().width;
    const nx = Math.max(size*0.15, Math.min(window.innerWidth - size*0.15, x));
    const ny = Math.max(size*0.15, Math.min(window.innerHeight - size*0.15, y));
    lens.style.left = nx+"px";
    lens.style.top  = ny+"px";
  }
  lens.addEventListener("pointerdown",(e)=>{
    dragging=true;
    const r=lens.getBoundingClientRect();
    offX=e.clientX-(r.left+r.width/2);
    offY=e.clientY-(r.top+r.height/2);
    lens.setPointerCapture(e.pointerId);
  });
  lens.addEventListener("pointermove",(e)=>{
    if(!dragging) return;
    setLensPos(e.clientX-offX, e.clientY-offY);
  });
  lens.addEventListener("pointerup",(e)=>{
    dragging=false;
    try{ lens.releasePointerCapture(e.pointerId);}catch{}
  });
  setLensPos(window.innerWidth*0.74, window.innerHeight*0.44);

  function clamp01(x){ return Math.max(0, Math.min(1, x)); }

  function tick(t){
    const now = performance.now();
    const lensInfo = lensCenter();

    // trigger
    for(const sp of spans){
      if(sp.dataset.hit!=="1") continue;
      if(isHit(sp, lensInfo)){
        const obj=ensureInfected(sp);
        sp.classList.add("hideInk");
        obj.svg.classList.add("on");
      }
    }

    // layout blob SVGs
    for(const obj of infected.values()){
      obj.prog = clamp01(Math.max(obj.prog, (now-obj.startedAt)/6500));

      const r = obj.span.getBoundingClientRect();
      const cx = r.left + r.width/2;
      const cy = r.top  + r.height/2;

      // Size: match original word block with comfortable padding
      const targetW = Math.max(160, r.width * 1.55);
      const targetH = Math.max(120, r.height * 1.85);

      const w = Math.round(targetW);
      const h = Math.round(targetH);

      obj.svg.style.left = cx + "px";
      obj.svg.style.top  = cy + "px";
      obj.svg.style.transform = "translate(-50%,-55%)";

      if (obj.lastW !== w || obj.lastH !== h){
        obj.lastW = w; obj.lastH = h;
        obj.svg.setAttribute("width", String(w));
        obj.svg.setAttribute("height", String(h));
        obj.svg.setAttribute("viewBox", `0 0 ${w} ${h}`);

        // font size: tie to span height (keeps legibility)
        const fs = Math.max(44, Math.min(260, Math.floor(r.height * 1.35)));
        obj.svg._textNode.setAttribute("font-size", String(fs));
        obj.svg._textNode.setAttribute("x", String(w/2));
        obj.svg._textNode.setAttribute("y", String(h/2));
      }
    }

    // blackout → final
    if(infectionStart){
      const seconds = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--fadeSeconds")) || 6.5;
      const globalProg = clamp01((now - infectionStart) / (seconds*1000));
      blackout.style.opacity = String(Math.pow(globalProg, 0.52));

      if(globalProg >= 0.995 && !document.body.classList.contains("final")){
        document.body.classList.add("final");
        blackout.style.opacity = "1";
        lens.style.display = "none";
      }
    }

    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  window.addEventListener("resize", ()=>{
    const r=lens.getBoundingClientRect();
    setLensPos(r.left+r.width/2, r.top+r.height/2);
  });
})();
</script>
</body>
</html>
