<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Appropriation Film — Noun-only</title>
  <style>
    :root{
      --bg:#ffffff;
      --ink:#111;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    body{ margin:0; background:var(--bg); color:var(--ink); }
    .wrap{ width:min(920px, 92vw); margin:0 auto; padding:44px 16px 180px; }
    header{
      position: sticky; top: 0; z-index: 3;
      background: rgba(255,255,255,.86);
      backdrop-filter: blur(8px);
      border-bottom: 1px solid rgba(0,0,0,.08);
      padding: 10px 0 12px;
    }
    header h1{ margin:0; font-family:var(--sans); font-size:18px; font-weight:700; }
    header p{ margin:6px 0 0; font-size:13px; opacity:.72; }

    #content{
      margin-top: 16px;
      font-family: var(--mono);
      font-size: 16px;
      line-height: 1.95;
      white-space: pre-wrap;
      word-break: keep-all;
      letter-spacing: .01em;
    }

    .sent{ display:inline; padding:2px 0; border-radius:8px; }

    /* 바뀐 단어만 살짝 “표시” */
    .tok{
      border-radius: 8px;
      padding: 0 2px;
      transition: background .12s ease;
    }
    .tok.ap{
      background: rgba(0,0,0,.06);
      box-shadow: 0 0 0 1px rgba(0,0,0,.10) inset;
      font-weight: 750;
      color:#000;
    }

    #swatch{
      position: fixed;
      right: 18px;
      bottom: 18px;
      width: 52px;
      height: 52px;
      border-radius: 44% 56% 42% 58% / 54% 40% 60% 46%;
      border: 1px solid rgba(0,0,0,.14);
      background: rgba(255,255,255,.9);
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 30px rgba(0,0,0,.12);
      cursor: pointer;
      z-index: 9999;
      display:grid;
      place-items:center;
      user-select:none;
    }
    #swatch .inner{
      width: 18px; height: 18px;
      border-radius: 999px;
      background: rgba(0,0,0,.82);
      box-shadow: 0 0 0 6px rgba(0,0,0,.06), 0 0 0 1px rgba(0,0,0,.14) inset;
    }

    #film{
      position: fixed;
      right: 18px;
      bottom: 78px;
      width: min(560px, 86vw);
      height: min(380px, 52vh);
      border-radius: 48% 52% 44% 56% / 55% 38% 62% 45%;
      border: 1px solid rgba(0,0,0,.18);
      background: rgba(0,0,0,.05);
      backdrop-filter: blur(2px) contrast(105%);
      box-shadow: 0 12px 40px rgba(0,0,0,.18);
      z-index: 9998;
      transform-origin: 100% 100%;
      transform: scale(0.15);
      opacity: 0;
      pointer-events: none;
      transition: transform .22s ease, opacity .22s ease;
      overflow: hidden;
    }
    body.filmOn #film{
      transform: scale(1);
      opacity: 1;
      pointer-events: auto;
    }

    #film::before{
      content:"";
      position:absolute; inset:-24px;
      background:
        radial-gradient(circle at 20% 30%, rgba(255,255,255,.30), transparent 55%),
        radial-gradient(circle at 70% 60%, rgba(255,255,255,.18), transparent 50%),
        repeating-linear-gradient(25deg, rgba(255,255,255,.14) 0 2px, transparent 2px 8px);
      opacity:.35;
      mix-blend-mode: screen;
      pointer-events:none;
    }
    #film::after{
      content:"";
      position:absolute; inset:-10px;
      background: radial-gradient(rgba(0,0,0,.22) 1px, transparent 1.8px);
      background-size: 11px 11px;
      opacity:.10;
      mix-blend-mode: multiply;
      pointer-events:none;
    }

    #filmHeader{
      height: 28px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 0 10px;
      font-family: var(--sans);
      font-size: 12px;
      color: rgba(0,0,0,.55);
      border-bottom: 1px solid rgba(0,0,0,.10);
      background: rgba(255,255,255,.45);
      cursor: grab;
      user-select:none;
    }
    #filmHeader:active{ cursor: grabbing; }
    #closeFilm{
      border:none; background:transparent; cursor:pointer;
      font-size:16px; line-height:1; opacity:.6;
    }
    #filmBody{
      height: calc(100% - 28px);
      padding: 10px;
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.55;
      color: rgba(0,0,0,.55);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>전유된 대화: 내 욕망으로 번역되는 타자의 목소리</h1>
      <p>검은 점을 눌러 필름을 펼치고 드래그하세요. 필름 안에 들어온 문장에서 ‘명사(핵심어)’만 자산/제품/수익의 언어로 치환됩니다.</p>
    </header>
    <div id="content"></div>
  </div>

  <div id="swatch" aria-label="Open film"><div class="inner"></div></div>

  <div id="film" role="dialog" aria-label="Appropriation film">
    <div id="filmHeader">
      <span>APPROPRIATION FILM</span>
      <button id="closeFilm" aria-label="Close">×</button>
    </div>
    <div id="filmBody">
      (필름 안쪽) forest / spirits / bees / law … 같은 핵심어만 <b>강제 번역</b>됩니다.
    </div>
  </div>

  <script>
    // ✅ 원문 길게 붙여넣기
    const TEXT = `
The napenaperi spirits want to keep the beauty of their mirror-land and protect it from epidemic fumes.
Bees are also xapiri; this is why their images spoke to me this way during my sleep.
Then they discovered the beauty of merchandise and started making it relentlessly.
This is how little by little the forest disappeared from their land along with the game that inhabited it.
`.trim();

    // ✅ “명사(핵심어) 번역” 맵: 여기만 잘 잡으면 작품이 된다
    // 키는 정규식. 가능한 한 “대상/개체”에 해당하는 단어(명사)를 중심으로.
    const NOUN_MAP = [
      { re: /\bforest\b/gi, to: "Asset" },
      { re: /\btrees?\b/gi, to: "Resource" },
      { re: /\bspirits?\b/gi, to: "IP" },
      { re: /\bxapiri\b/gi, to: "Intangible" },
      { re: /\bbees?\b/gi, to: "Product" },
      { re: /\bhoney\b/gi, to: "Revenue" },
      { re: /\bflowers?\b/gi, to: "Input" },
      { re: /\bland\b/gi, to: "Property" },
      { re: /\bknowledge\b/gi, to: "Patent" },
      { re: /\blaw\b/gi, to: "Policy" },
      { re: /\bmemory\b/gi, to: "Database" },
      { re: /\bsong(s)?\b/gi, to: "Content" },
      { re: /\bimage(s)?\b/gi, to: "Brand" },
      { re: /\bmedicine\b/gi, to: "Product" },
      { re: /\bmerchandise\b/gi, to: "Inventory" },
      { re: /\bcities?\b/gi, to: "Market" },
      { re: /\bhouses?\b/gi, to: "Facility" },
      { re: /\bgardens?\b/gi, to: "Production" },
      { re: /\bgame\b/gi, to: "Stock" },
    ];

    // 문장 분리 (가벼운 버전)
    function splitSentences(text){
      const paras = text.replace(/\r/g,"").split(/\n{2,}/);
      return paras.map(p => p.split(/(?<=[.!?])\s+(?=[A-Z“"‘(])/g));
    }
    function escapeHtml(str){
      return str
        .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
        .replaceAll('"',"&quot;").replaceAll("'","&#039;");
    }

    // ✅ “명사만 치환”: 원문을 HTML로 만들면서 치환된 토큰만 span 표시
    function nounOnlyTransform(sentence){
      // 1) 일단 이스케이프
      let s = escapeHtml(sentence);

      // 2) 치환: 겹치지 않게 임시 토큰으로 바꾼 뒤 마지막에 마크업
      //    (치환 단어에 다시 치환이 걸리는 걸 막기 위해 placeholder 사용)
      const placeholders = [];
      NOUN_MAP.forEach(({re,to}, idx) => {
        // HTML 상태라 정규식은 원문 기준이 더 안전 -> sentence에서 작업하고 다시 조립
      });

      // 원문 기반 치환을 위해 원문을 순차적으로 처리
      let working = sentence;
      const marks = [];

      // 각 규칙마다 매치들을 찾아서 기록
      NOUN_MAP.forEach(({re,to}) => {
        let m;
        while ((m = re.exec(working)) !== null) {
          marks.push({ start: m.index, end: m.index + m[0].length, repl: to, raw: m[0] });
          if (m.index === re.lastIndex) re.lastIndex++; // 안전장치
        }
        re.lastIndex = 0; // 다음 문장에 영향 없게
      });

      if (marks.length === 0) return escapeHtml(sentence);

      // 겹치는 매치 정리: 길이가 긴 것 우선, 그 다음 앞쪽 우선
      marks.sort((a,b) => (b.end-b.start) - (a.end-a.start) || a.start - b.start);

      const chosen = [];
      const occupied = [];
      function overlaps(a,b){ return !(a.end <= b.start || a.start >= b.end); }

      for (const mk of marks){
        if (occupied.some(o => overlaps(o, mk))) continue;
        chosen.push(mk);
        occupied.push({start: mk.start, end: mk.end});
      }
      // 원문 순서로 재정렬
      chosen.sort((a,b)=>a.start-b.start);

      // 조립
      let out = "";
      let cursor = 0;
      for (const mk of chosen){
        out += escapeHtml(sentence.slice(cursor, mk.start));
        // 바뀐 단어만 표시(원문 단어를 자본 단어로 치환)
        out += `<span class="tok ap" title="${escapeHtml(mk.raw)}">${escapeHtml(mk.repl)}</span>`;
        cursor = mk.end;
      }
      out += escapeHtml(sentence.slice(cursor));
      return out;
    }

    // 렌더: 문장 span 생성 (원문 저장 + 변환 HTML 저장)
    const content = document.getElementById("content");
    const model = splitSentences(TEXT);

    function render(){
      content.innerHTML = "";
      model.forEach(sentList => {
        sentList.forEach(s => {
          const span = document.createElement("span");
          span.className = "sent";
          span.dataset.orig = s;
          span.dataset.transHtml = nounOnlyTransform(s);
          span.innerHTML = escapeHtml(s);
          content.appendChild(span);
          content.appendChild(document.createTextNode(" "));
        });
        content.appendChild(document.createTextNode("\n\n"));
      });
    }
    render();

    // 필름 토글
    const swatch = document.getElementById("swatch");
    const film = document.getElementById("film");
    const closeFilm = document.getElementById("closeFilm");
    const filmHeader = document.getElementById("filmHeader");

    let filmOn = false;
    function setFilm(on){
      filmOn = on;
      document.body.classList.toggle("filmOn", on);
      if (on) updateAppropriation();
      else clearAll();
    }
    swatch.addEventListener("click", () => setFilm(!filmOn));
    closeFilm.addEventListener("click", () => setFilm(false));

    // 드래그 이동
    let drag = { on:false, startX:0, startY:0, baseX:0, baseY:0 };
    function ensureFilmPositioned(){
      const r = film.getBoundingClientRect();
      if (film.style.left) return;
      film.style.left = r.left + "px";
      film.style.top  = r.top  + "px";
      film.style.right = "auto";
      film.style.bottom = "auto";
    }
    filmHeader.addEventListener("pointerdown", (e) => {
      if (!filmOn) return;
      ensureFilmPositioned();
      drag.on = true;
      drag.startX = e.clientX;
      drag.startY = e.clientY;
      drag.baseX = parseFloat(film.style.left);
      drag.baseY = parseFloat(film.style.top);
      filmHeader.setPointerCapture(e.pointerId);
    });
    filmHeader.addEventListener("pointermove", (e) => {
      if (!drag.on) return;
      const dx = e.clientX - drag.startX;
      const dy = e.clientY - drag.startY;
      film.style.left = (drag.baseX + dx) + "px";
      film.style.top  = (drag.baseY + dy) + "px";
      updateAppropriation();
    });
    filmHeader.addEventListener("pointerup", (e) => {
      drag.on = false;
      try { filmHeader.releasePointerCapture(e.pointerId); } catch {}
    });

    // 필름 안 문장만 변환 적용
    const spans = () => Array.from(content.querySelectorAll(".sent"));
    function rectsOverlap(a,b){
      return !(a.right < b.left || a.left > b.right || a.bottom < b.top || a.top > b.bottom);
    }

    function appropriate(span){
      if (span.dataset.state === "ap") return;
      span.dataset.state = "ap";
      span.innerHTML = span.dataset.transHtml || span.textContent;
    }
    function restore(span){
      if (span.dataset.state !== "ap") return;
      span.dataset.state = "orig";
      span.innerHTML = escapeHtml(span.dataset.orig || "");
    }
    function clearAll(){ spans().forEach(restore); }

    function updateAppropriation(){
      if (!filmOn) return;
      const f = film.getBoundingClientRect();
      const effective = {
        left: f.left + 12,
        top: f.top + 40,
        right: f.right - 12,
        bottom: f.bottom - 12
      };
      spans().forEach(sp => {
        const r = sp.getBoundingClientRect();
        const hit = rectsOverlap(r, effective);
        if (hit) appropriate(sp);
        else restore(sp);
      });
    }

    window.addEventListener("scroll", () => updateAppropriation(), { passive:true });
    window.addEventListener("resize", () => updateAppropriation());
  </script>
</body>
</html>
